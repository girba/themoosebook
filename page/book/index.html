<!DOCTYPE html><html>	<head>		<title>The Moose Book</title>		<meta name="author" content="Tudor Girba">		<meta charset="utf-8">		<meta name="viewport" content="width=device-width, initial-scale=1">		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>		<style>				.nav-pills>li.active>a {	background-color: transparent;	color: #337ab7;}.nav-pills>li.active>a:focus,.nav-pills>li.active>a:hover {	background-color: #eee;	color: #337ab7;}.nav-pills>li>a {	border-radius: 0px;}.nav-pills {   top: 20px;   position: fixed;}/* hide sidebar sub menus by default */.nav-pills li .nav-h2 {  display: none;}/* show sub menu when parent is active */.nav-pills li.active .nav-h2 {  display: block;}.nav-pills>li.active {	border-left: 2px solid #ddd;}.nav-pills>li.active>a {  border-left: 6px solid #ddd;}.nav-pills>li.active li.active a {  border-left: 6px solid #eee;}.nav-pills>li.active li a {  border-left: 6px solid transparent;}ul .nav-h3 {display: none;}.nav-pills li a {	padding-top: 5px;	padding-bottom: 5px;	font-size: 14px;}.nav-pills li li a {	padding-top: 5px;	padding-bottom: 5px;	font-size: 11px;}img {max-width: 100%;}.todo { padding: 20px; background-color: #F9F2F4; }.note { padding: 20px; background-color: #DBECFF; }figcaption { text-align: center; color: gray; }figure { padding: 20px; text-align: center; }figure pre { text-align: left; }code { background-color: #eee; color: #333; }		</style>	</head>	<body data-spy="scroll" data-target="#myScrollspy" data-offset="20">		<div class="container">			<div class="row">				<nav class="col-sm-3" id="myScrollspy">					
<ul class="nav nav-pills nav-stacked">
<li>
<a href="#h1mooseinanutshell">Moose in a nutshell</a>
<ul class="nav nav-h2">
<li>
<a href="#h2mooseinaction">Moose in action</a>
<ul class="nav nav-h3">
<li>
<a href="#h3analyzingjavacode">Analyzing Java code</a></li>
<li>
<a href="#h3navigatingxmlfiles">Navigating XML files</a></li>
<li>
<a href="#h3beyondstructuredtext">Beyond structured text</a></li></ul></li>
<li>
<a href="#h2mooseoverview">Moose overview</a>
<ul class="nav nav-h3">
<li>
<a href="#h3petitparser">PetitParser</a></li>
<li>
<a href="#h3fame,famix,mse">Fame, FAMIX, MSE</a></li>
<li>
<a href="#h3roassal">Roassal</a></li>
<li>
<a href="#h3glamour">Glamour</a></li>
<li>
<a href="#h3finder">Finder</a></li>
<li>
<a href="#h3theglamoroustoolkit">The Glamorous Toolkit</a></li>
<li>
<a href="#h3otherenginesandtools">Other engines and tools</a></li></ul></li>
<li>
<a href="#h2summary">Summary</a></li></ul></li>
<li>
<a href="#h1importingandexportingmodels">Importing and exporting models</a>
<ul class="nav nav-h2">
<li>
<a href="#h2importingandexportingwithmse">Importing and exporting with MSE</a></li>
<li>
<a href="#h2importingpharocode">Importing Pharo code</a></li>
<li>
<a href="#h2importingjavacode">Importing Java code</a></li>
<li>
<a href="#h2settingtherootfolder">Setting the root folder</a></li></ul></li>
<li>
<a href="#h1writingparserswithpetitparser">Writing parsers with PetitParser</a>
<ul class="nav nav-h2">
<li>
<a href="#h2stepbystepparsingofmse">Step by step parsing of MSE</a>
<ul class="nav nav-h3">
<li>
<a href="#h3startingsmallwithparsingnames">Starting small with parsing names</a></li>
<li>
<a href="#h3manipulatingtheoutputofparsingstringsandnumbers">Manipulating the output of parsing strings and numbers</a></li>
<li>
<a href="#h3dealingwithcyclicdependencieswhenscriptingthemsegrammar">Dealing with cyclic dependencies when scripting the MSE grammar</a></li>
<li>
<a href="#h3encapsulatingthemsegrammarinaclass">Encapsulating the MSE grammar in a class</a></li>
<li>
<a href="#h3testingthemsegrammarclass">Testing the MSE grammar class</a></li>
<li>
<a href="#h3creatinganmseparser">Creating an MSE parser</a></li></ul></li>
<li>
<a href="#h2parsingoperators">Parsing operators</a></li>
<li>
<a href="#h2dedicateduserinterface">Dedicated user interface</a></li></ul></li>
<li>
<a href="#h1meta-modelingwithfame">Meta-modeling with Fame</a>
<ul class="nav nav-h2">
<li>
<a href="#h2thefm3meta-meta-model">The FM3 meta-meta-model</a></li>
<li>
<a href="#h2subject,model,meta-model,meta-meta-model">Subject, model, meta-model, meta-meta-model</a></li>
<li>
<a href="#h2pharointegration">Pharo integration</a></li></ul></li>
<li>
<a href="#h1thecoremeta-model">The core meta-model</a>
<ul class="nav nav-h2">
<li>
<a href="#h2theentity">The Entity</a></li>
<li>
<a href="#h2thegroup">The Group</a></li>
<li>
<a href="#h2themodel">The Model</a></li></ul></li>
<li>
<a href="#h1thefamixfamilyofmeta-models">The FAMIX family of meta-models</a>
<ul class="nav nav-h2">
<li>
<a href="#h2thecorelanguage-independentmeta-model">The core language-independent meta-model</a>
<ul class="nav nav-h3">
<li>
<a href="#h3anincorrect,butusefuloverview">An incorrect, but useful overview</a></li>
<li>
<a href="#h3types">Types</a></li>
<li>
<a href="#h3theinvocation">The invocation</a></li>
<li>
<a href="#h3theannotations">The annotations</a></li>
<li>
<a href="#h3famixgenericqueryapi">Famix generic query API</a></li></ul></li>
<li>
<a href="#h2meta-modelextensions">Meta-model extensions</a></li>
<li>
<a href="#h2themetabrowser">The Meta Browser</a></li></ul></li>
<li>
<a href="#h1paintingobjectswithroassal">Painting objects with Roassal</a>
<ul class="nav nav-h2">
<li>
<a href="#h2roassalinaction">Roassal in action</a></li>
<li>
<a href="#h2visualizingdependenciesbetweentarget">Visualizing dependencies between target </a></li></ul></li>
<li>
<a href="#h1buildingbrowserswithglamour">Building browsers with Glamour</a>
<ul class="nav nav-h2">
<li>
<a href="#h2aglimpseofglamour">A glimpse of Glamour</a></li>
<li>
<a href="#h2glamourarchitecture">Glamour architecture</a></li>
<li>
<a href="#h2sketchingbrowsers">Sketching browsers</a></li>
<li>
<a href="#h2handlingtransmissions">Handling transmissions</a></li>
<li>
<a href="#h2specifyingpresentations">Specifying presentations</a>
<ul class="nav nav-h3">
<li>
<a href="#h3compositepresentation">Composite presentation</a></li>
<li>
<a href="#h3listingpresentations">Listing presentations</a></li>
<li>
<a href="#h3textpresentation">Text presentation</a></li>
<li>
<a href="#h3labelpresentation">Label presentation</a></li>
<li>
<a href="#h3smalltalkcodepresentation">Smalltalk code presentation</a></li>
<li>
<a href="#h3roassalpresentation">Roassal presentation</a></li>
<li>
<a href="#h3magrittepresentation">Magritte presentation</a></li>
<li>
<a href="#h3diffpresentation">Diff presentation</a></li>
<li>
<a href="#h3dynamicpresentation">Dynamic presentation</a></li>
<li>
<a href="#h3custompresentations">Custom presentations</a></li></ul></li>
<li>
<a href="#h2scriptingbrowsers">Scripting browsers</a>
<ul class="nav nav-h3">
<li>
<a href="#h3tabulator">Tabulator</a></li>
<li>
<a href="#h3finderandpager">Finder and Pager</a></li>
<li>
<a href="#h3accumulator">Accumulator</a></li>
<li>
<a href="#h3composingbrowsers">Composing browsers</a></li></ul></li>
<li>
<a href="#h2handlingactions">Handling actions</a></li>
<li>
<a href="#h2updatingbrowsers">Updating browsers</a></li>
<li>
<a href="#h2rendering">Rendering</a></li>
<li>
<a href="#h2examples">Examples</a></li></ul></li>
<li>
<a href="#h1theglamoroustoolkit">The Glamorous Toolkit</a></li>
<li>
<a href="#h1checkingandreportingwitharki">Checking and reporting with Arki</a>
<ul class="nav nav-h2">
<li>
<a href="#h2creatingadedicatedreportfromscratch">Creating a dedicated report from scratch</a></li></ul></li></ul>				</nav>				<div class="col-sm-9">					<p>
<h1 id="h1mooseinanutshell">Moose in a nutshell</h1>

<p>
Moose (<a href="http://moosetechnology.org">moosetechnology.org</a>) is a platform for expressing analyses of software systems and of data in general. Its main goal is to assist and enable a human in the process of understanding large amounts of data. It addresses several categories of users:
</p><ul>
<li>researchers in the area of software analysis, mining and reverse engineering,</li>
<li>engineers and architects who want to understand systems and data, and</li>
<li>tool builders.</li>
</ul>

<p>
This book covers Moose from various angles. It covers its externals, its internals, and the philosophy behind its design. 
</p>
<h2 id="h2mooseinaction">Moose in action</h2>

<p>
Let's start from a couple of examples around a case study. In our case, we take ArgoUML, an open-source Java project.
</p>
<h3 id="h3analyzingjavacode">Analyzing Java code</h3>

<p>
The system contains some deprecated classes. A typical question is which of these classes we can remove. Essentially, this boils down to finding the classes annotated with <code>@Deprecated</code> and then selecting those that are not used anywhere (we ignore reflection for this exercise). This is an analysis.
</p>
<p>
We first need to build a model of our system, and for this we will use <a href="https://github.com/girba/jdt2famix">jdt2famix</a>:
</p><ul>
<li>Download and unzip <a href="https://github.com/girba/jdt2famix/releases/download/1.0.2/jdt2famix-bin-1.0.2.zip">version 1.0.2</a>.</li>
<li>Create an <code>ArgoUML-0-34</code> folder.</li>
<li><a href="http://argouml-downloads.tigris.org/nonav/argouml-0.34/ArgoUML-0.34-src.zip">Download the ArgoUML version 0.34 sources</a> and place them in <code>ArgoUML-0-34/src</code> folder (the name of the src folder can be arbitrary)</li>
<li><a href="http://argouml-downloads.tigris.org/nonav/argouml-0.34/ArgoUML-0.34-libs.zip">Download the ArgoUML version 0.34 libraries</a> and place them in <code>ArgoUML-0-34/libs</code> folder  (the name of the libs folder can be arbitrary)</li>
<li>Go to the <code>ArgoUML-0-34</code> folder</li>
<li>From the command line execute <code>path/to/jdt2famix/sh</code></li>
</ul>

<p>
The result is that you will get an <code>ArgoUML-0-34/ArgoUML-0-34.mse</code> file with the serialized model that can be loaded in Moose. Make sure you have <a href="http://moosetechnology.org/#install">Moose 6.0 or later</a>.
</p>
<p>
Starting Moose you see the following window:
</p>
<p>

<figure>
	<img src="figures/moose-panel-1.png"/>
	<figcaption>Moose Panel</figcaption>
</figure>
</p>
<p>
Click on the MSE button on the top right and load the <code>ArgoUML-0-34.mse</code> file. 
</p>
<p>
An extra step is to point the model to the sources folder. To this end, right click on the <code>ArgoUML-0-34</code> model, choose <code>Utilities/Set root folder</code> and point to the <code>ArgoUML-0-34</code> folder.
</p>
<p>
Now we are ready to query our system. Select <code>All model classes</code>.
</p>
<p>

<figure>
	<img src="figures/moose-panel-2.png"/>
	<figcaption>All model classes</figcaption>
</figure>
</p>
<p>
By default you see the list of classes. At this point we are only interested in the deprecated classes, so let's select only those. Choose the playground tab (the one that looks like [|]) and type:
</p>
<figure><pre><code>self select: [ :each | each isAnnotatedWith: 'Deprecated' ]</code></pre><figcaption></figcaption></figure>

<p>
Select the whole text and from the contextual menu choose <code>Do it and go</code> (Cmd+g). This results in a new pane that spawns to the right containing 25 classes.
</p>
<p>

<figure>
	<img src="figures/moose-panel-3.png"/>
	<figcaption>Deprecated classes</figcaption>
</figure>
</p>
<p>
Just to make sure that we indeed got deprecated classes, let's investigate one of them and select to view the source code.
</p>
<p>

<figure>
	<img src="figures/moose-panel-4.png"/>
	<figcaption>One deprecated class with source code</figcaption>
</figure>
</p>
<p>
Let's step back for a moment. We see 2 panes at the moment, but we have 4 panes in total in our browser. Each pane represents one object and offers multiple views on this object. Furthermore, each pane is also represented by a dot in the scroll bar from the bottom. Hovering over a dot spawns a preview of the pane. If we want to see more or less panes we can do so by dragging the margins of the bar.
</p>
<p>

<figure>
	<img src="figures/moose-panel-5.png"/>
	<figcaption>Three panes</figcaption>
</figure>
</p>
<p>
But, let's go back to our original problem. We now have the 25 classes that are deprecated in our system. Next, we need to check which of those are not used. Or if we think in terms of clients and providers, which of the deprecated classes do not have client classes. Open the playground corresponding to the pane with having 25 classes and execute the following expression:
</p>
<figure><pre><code>self select: [ :each | each clientTypes isEmpty]</code></pre><figcaption></figcaption></figure>

<p>
We get 14 classes that can be removed immediately.
</p>
<p>

<figure>
	<img src="figures/moose-panel-6.png"/>
	<figcaption>Deprecated classes without clients</figcaption>
</figure>
</p>
<p>
This leaves us with 11 classes that cannot be removed because they are still being used. So, what should we do about these?
</p>
<p>

<figure>
	<img src="figures/moose-panel-7.png"/>
	<figcaption>Deprecated classes with clients</figcaption>
</figure>
</p>
<p>
It would be great to know how these classes are being used. Perhaps there is one deprecated class that is used in several places. Or maybe there is one non-depreated class that uses multiple deprecated ones. Or it can also be that multiple deprecated classes call each other. A plain list presentation is not quite ideal to exhibit these patterns. So, let's build a visualization instead.
</p>
<p>
In the pane of the 11 classes execute in the playground:
</p>
<figure><pre><code>| view |
view := RTMondrian new.
view nodes: (self, (self flatCollect: #clientTypes)) asSet.
view layout grid.
view</code></pre><figcaption></figcaption></figure>

<p>
This shows us a simple visualization containing the 11 deprecated classes and their client types.
</p>
<p>

<figure>
	<img src="figures/moose-panel-8.png"/>
	<figcaption>Simple visualization of used deprecated classes and their clients</figcaption>
</figure>
</p>
<p>
What we get is an interactive picture, and clicking on a node reveals the details of the actual class to the right.
</p>
<p>

<figure>
	<img src="figures/moose-panel-9.png"/>
	<figcaption>Obtaining details from the visualization</figcaption>
</figure>
</p>
<p>
Let's now distinguish between the deprecated and the non-deprecated classes:
</p>
<figure><pre><code>| view |
view := RTMondrian new.
view shape circle 
	if: [ :each | each isAnnotatedWith: 'Deprecated' ] 
	color: Color red.
view nodes: (self, (self flatCollect: #clientTypes)) asSet.
view layout grid.
view</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/moose-panel-10.png"/>
	<figcaption>Distinguishuing between deprecated and non-deprecated classes</figcaption>
</figure>
</p>
<p>
Ok, now we see the classes, but what are the dependencies?
</p>
<figure><pre><code>| view |
view := RTMondrian new.
view shape circle 
	if: [ :each | each isAnnotatedWith: 'Deprecated' ] 
	color: Color red.
view nodes: (self, (self flatCollect: #clientTypes)) asSet.
view edges connectFromAll: #clientTypes.
view layout grid.
view view pushBackEdges.
view</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/moose-panel-11.png"/>
	<figcaption>Representing dependencies through edges</figcaption>
</figure>
</p>
<p>
Now, let's arrange the graph a bit better.
</p>
<figure><pre><code>| view |
view := RTMondrian new.
view shape circle 
	if: [ :each | each isAnnotatedWith: 'Deprecated' ] 
	color: Color red.
view nodes: (self, (self flatCollect: #clientTypes)) asSet.
view edges connectFromAll: #clientTypes.
view layout force.
view view pushBackEdges.
view</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/moose-panel-12.png"/>
	<figcaption>Patterns of usages of deprecated classes</figcaption>
</figure>
</p>
<p>
Ok. Now, we can distinguish several distinct situations. Two deprecated classes call each other and they can be simply removed. There is one non-deprecated class using two deprecated classes. And there are 3 deprecated classes that are being used by several other non-deprecated ones. This picture offers us the opportunity to choose our path by taking more details into account at the same time. For example, an interesting candidate to investigate is the one class that uses two deprecated ones.
</p>
<h3 id="h3navigatingxmlfiles">Navigating XML files</h3>

<p>
Working with code is interesting but often the plain code does not provide the complete story. For example, ArgoUML happens to rely on some Ant XML files for building the system. Let's look at them. To this end, click on the background of Pharo and from the so called World menu choose <code>Playground</code>. If you are new to Pharo, the Playground is a little tool that allows you to evaluate scripts. We start with inspecting the object representing the root directory of our <code>ArgoUML-0-34</code> model. 
</p>
<figure><pre><code>MooseModel root allModels anyOne rootFolder asFileReference</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/playground-files-1.png"/>
	<figcaption>Inspecting directories</figcaption>
</figure>
</p>
<p>
We want to find the Ant XML files. We could write a query, but let's first get a sense of what kind of files exist in the project. For this, we choose the <code>Grouped files</code> presentation of the <code>src</code> folder.
</p>
<p>

<figure>
	<img src="figures/playground-files-2.png"/>
	<figcaption>Overview of files by extension</figcaption>
</figure>
</p>
<p>
We see that we get 614 XML files. We pick the first <code>build.xml</code>.
</p>
<p>

<figure>
	<img src="figures/playground-files-3.png"/>
	<figcaption>A build.xml</figcaption>
</figure>
</p>
<p>
The inspector shows the XML with syntax highlighting. Let's say that we want to understand the <code>&lt;property&gt;</code> elements from this file. One possibility would be to scroll through the file, but that would mean that we treat XML as text. Another way is to take advantage of the structure of XML. We switch to the <code>Raw</code> view and we parse the file.
</p>
<figure><pre><code>XMLDOMParser parse: self contents</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/playground-files-4.png"/>
	<figcaption>Inspecting an XML document</figcaption>
</figure>
</p>
<p>
The tree is more appropriate for  navigation, but still we are required to scroll. Instead, we should only care about the <code>&lt;property&gt;</code> tags. To this end, we can use an XPath query.
</p>
<figure><pre><code>self // #property</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/playground-files-5.png"/>
	<figcaption>Using XPath to find elements of interest</figcaption>
</figure>
</p>
<p>
The result is only a list of 44 <code>&lt;property&gt;</code> tags. Now we can read.
</p>

<h3 id="h3beyondstructuredtext">Beyond structured text</h3>

<p>
The previous examples show how the same interaction metaphor that we can use for navigating models of code, can be used to navigate and reason about arbitrary objects, such as objects representing files and folders. But, what happens when we do not have easy access to those objects?
</p>
<p>
Let's consider another example. The <a href="https://raw.githubusercontent.com/girba/themoosebook/master/Chapters/Nutshell/index.pillar">source of this chapter</a>  uses Pillar, a markup language. As with any technical documentation, it contains code, and very often we just want to scheme through that code. Of course, we could just scroll through the whole document, but that is not really cool. So, let's set to extract only the snippets.
</p>
<p>
First, we need the source. Open another Playground by clicking on the background of the window and inspect:
</p>
<figure><pre><code>ZnClient new
	url: 'https://raw.githubusercontent.com/girba/themoosebook/master/book/Chapters/Nutshell/index.pillar';
	get</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/playground-pillar-1.png"/>
	<figcaption>Obtaining the remote source code</figcaption>
</figure>
</p>
<p>
Looking at the first code snippet, we notice that it is introduced through a pattern like <code>[[[ ... ]]]</code>. To extract this pattern, we need a parser. Suppose we do not have a parser at hand. It follows that we should build one. But, given that  we are not interested at this time in the whole grammar of the markup language, we should be able to extract only the snippet we care about. Switch to the <code>Raw</code> presentation and evaluate:
</p>
<figure><pre><code>p := (('[[[' asParser , ']]]' asParser negate plus flatten , ']]]' asParser 
	==&gt; #second) sea 
	==&gt; #second) star.
p parse: self contents.</code></pre><figcaption></figcaption></figure>

<p>
Evaluating this code, extracts the wanted snippets. Now we can read.
</p>
<p>

<figure>
	<img src="figures/playground-pillar-2.png"/>
	<figcaption>Extracting code snippets</figcaption>
</figure>
</p>

<h2 id="h2mooseoverview">Moose overview</h2>
<p>
The examples above exercised several Moose components. Let's take a step back and observe the overall structure of Moose.
</p>
<p>
Moose is a generic platform for engineers that want to understand data in general, and software systems in particular.  Foremost, Moose is designed for programmers, not for clickers. To get the most out of it, you have to program it. First, that means that you have to program in <a href="http://pharo.org">Pharo</a>. Second, you have to learn the inner workings of Moose to understand how to use it.
</p>
<p>
This is actually less difficult than it sounds. Pharo is a beautiful language, and if you do not know it already, you will not be sorry for learning it. And Moose is rather small having less than 2000 classes and less than 150k lines of code. Let's take a quick tour.
</p>
<p>
From a conceptual point of view, Moose is organized as follows.
</p>
<p>

<figure>
	<img src="figures/moose-workflow.png"/>
	<figcaption>Moose workflow</figcaption>
</figure>
</p>
<p>
The picture emphasizes two aspects:
</p><ol><li>The analysis process is iterative. Once data imported, the input to the actual analysis is a model. Applying an analysis yields another model that can be further analyzed. This is somewhat similar to a pipes-and-filters design, only it involves more feedback and interaction possibilities.</li>
<li>The analysis process is customizable. The job of dedicated engines is to help the engineer craft new importers, models and analyses.</li>
</ol>

<p>
This might sound like mumbo jumbo, but let us take a moment and consider how this diagram is instantiated through a couple of examples.
</p>
<p>
The input is always some piece of data. By data, we understand all sorts of structures that contain objects, properties and relations. For example, data can be a software system written in Java. Or it can be a set of configuration files written in XML. Or it can be some meta-data about your system. Or it can be a text file.
</p>
<p>
This data is loaded in Moose via importers. You can import data from various sources and in various formats. For example, you can import the structure of software systems either through internal importers (e.g., for Smalltalk code, XML, JSON, MSE), or through external ones (e.g., Java).
</p>
<p>
The importing of data can be perceived as a rather unexciting step, but it is a necessary one. Once imported, the data is stored into models. This is where things get more interesting because on top of these models you can start performing various kinds of analyses.
</p>
<p>
What do we mean by analyses? Metrics, queries, interactive visualizations etc. There a multitude of basic services like these provided by default. These tools can be applied interactively, and can be combined to produce more complex analyses such as: computation of dependency cycles, detection of high level design problems, identification of exceptional entities and so on. A key concept is that the results obtained after applying a specific analysis are fed back into the model and are available for further analysis. This enables an iterative process through which the analysis is built and refined gradually.
</p>
<p>
But, Moose is more than a tool. Moose is a platform. This is not just marketing, and it actually means that it is designed to help you build your own tools. This is achieved by means of several engines through which you can control and customize the complete analysis workflow. In particular, you can:
</p><ul>
<li>build new importers for new data sets,</li>
<li>define new models to store the data, and</li>
<li>create new analysis algorithms and tools such as: complex graph visualizations, charts, new queries, or even complete browsers and reporting tools altogether.</li>
</ul>

<p>
Let's now take a closer look at some of these engines.
</p>
<h3 id="h3petitparser">PetitParser</h3>

<p>
PetitParser is a parsing engine. Its goal is to help engineers craft parsers for various programming languages and data formats.
</p>
<p>

<figure>
	<img src="figures/petitparser-workflow.png"/>
	<figcaption>PetitParser</figcaption>
</figure>
</p>
<p>
For example, to build a parser for SQLite, you can follow the official abstract grammar (see <a href="http://www.sqlite.org/syntaxdiagrams.html">http://www.sqlite.org/syntaxdiagrams.html</a>). In this grammar, the <code>selectCore</code> is one of the central productions and the specification looks like:
</p>
<p>

<figure>
	<img src="figures/sqlite-select-core.png"/>
	<figcaption>Select core SQLite production</figcaption>
</figure>
</p>
<p>
Using PetitParser, this becomes:
</p><figure><pre><code>select ,
(distinct / all) optional ,
(resultColumn separatedBy: $, asParser trim) ,
(from , joinSource) optional ,
(where , expression ) optional ,
(groupBy , 
	(orderingTerm separatedBy: $, asParser trim),
	('HAVING' asParser caseInsensitive trim , expression) optional
) optional</code></pre><figcaption></figcaption></figure>

<p>
Due to PetitParser's expressivity, the implementation is essentially as compact as the original abstract definition. This characteristic makes mapping abstract notations to actual implementation simple. But, PetitParser goes a step further than usual similar engines, and it also provides custom development tools. For example, it comes with a browser that lets the engineer navigate the structure of a parser, and debug the execution of a parser against a textual input.
</p>
<p>
In the picture below, you can see the definition of the <code>selectCore</code> production from the SQLite grammar. In the lower part, the programmer can enter a sample and debug the result. The debugger is interactive and shows which production matched which part of the input string (in our example, <code>joinSource</code> matches TABLE).
</p>
<p>

<figure>
	<img src="figures/pp-with-inspector.png"/>
	<figcaption>PetitParser browser with inspector</figcaption>
</figure>
</p>
<p>
Furthermore, the browser offers other visual representations of the grammar. For example, in the picture below, the browser shows a graphical decomposition of the <code>selectCore</code> production. The picture is essentially the same as the picture shown in the abstract grammar.
</p>
<p>

<figure>
	<img src="figures/pp-with-graph.png"/>
	<figcaption>PetitParser browser with graph</figcaption>
</figure>
</p>
<p>
Developing an analysis is a software development project, and it is subject to the same problems any software development project has. Given that Moose's aim is precisely to decrease the cost of analysis, having a dedicated environment covering the complete cycle of developing a parser is a key ingredient for decreasing the cost of building non-toy parsers.
</p>
<h3 id="h3fame,famix,mse">Fame, FAMIX, MSE</h3>

<p>
Fame is one of the two engines that provide the meta-modeling infrastructure of Moose. The other one is Magritte and it is mostly used for user interface purposes. Fame provides several things:
</p><ul>
<li>a meta-engine,</li>
<li>a compact serialization format (MSE) in which both models and meta-models can be serialized,</li>
<li>code generation possibilities, and</li>
<li>a Java implementation that is fully compatible with the Moose one. In particular, the latter allows us to easily populate a model from Java, export it to an MSE file, and then load it into Moose.</li>
</ul>

<p>

<figure>
	<img src="figures/fame-workflow.png"/>
	<figcaption>Fame</figcaption>
</figure>
</p>
<p>
Fame is essentially used for all meta-models used in Moose, the most prominent being FAMIX - a language independent meta-model for modeling software programs. For example, FAMIX models entities like Method, Attribute, or Access.
</p>
<p>
Fame attaches meta-descriptions to implementation via pragmas. For example, BehaviouralEntity is annotated on the class side like:
</p>
<figure><pre><code>FAMIXBehavioralEntity class&gt;&gt;annotation
     &lt;MSEClass: #BehaviouralEntity super: #FAMIXContainerEntity&gt;
     &lt;package: #FAMIX&gt;
     ^self</code></pre><figcaption></figcaption></figure>

<p>
Properties are annotated in a similar fashion. For example, the property pointing to all Access entities that originate in a BehavioralEntity is annotated in the getter method:
</p>
<figure><pre><code>FAMIXBehavioralEntity&gt;&gt;accesses
     &lt;MSEProperty: #accesses type: #FAMIXAccess opposite: #accessor&gt;
     &lt;multivalued&gt; &lt;derived&gt;
     &lt;MSEComment: 'Accesses to variables made by this behaviour.’&gt;
     ^ accesses</code></pre><figcaption></figcaption></figure>

<p>
Based on these annotations Fame constructs a meta-model that lives in parallel to the actual implementation and that offers extra information useful for scenarios like browsing or import-export.
</p>
<p>
An engine is not complete without at least a dedicated tool that helps you manage it. In particular, because with Fame you can define various meta-models implemented in the image via pragmas attached to the implementation classes, we need to keep track of what is available.
</p>
<p>
To this end, the Moose Meta Browser provides an easy way to keep an overview of the various meta-models available at any given time in the Moose image. The picture below shows the details of the BehaviouralEntity from FAMIX.
</p>
<p>

<figure>
	<img src="figures/meta-browser.png"/>
	<figcaption>The Meta Browser</figcaption>
</figure>
</p>
<p>
But, FAMIX is more than just a simple meta-model for software systems. It is also a rich API for querying those models.
</p>
<p>
Let’s look at an example. Suppose you want to look for all classes  that are not being directly called by JUnit test.
</p>
<figure><pre><code>model allModelClasses select: [:each | 
	each clientTypes noneSatisfy: #isJUnit4TestCase ]</code></pre><figcaption></figcaption></figure>

<p>
Having a highly expressive API brings makes querying inexpensive. And when you combine this ability with visual and interactive tools, you get a different way of experiencing your systems.
</p>
<h3 id="h3roassal">Roassal</h3>

<p>
Roassal is an engine for crafting interactive graph visualizations. For example, the visualization from the picture above is built using Roassal.
</p>
<p>

<figure>
	<img src="figures/roassal-workflow.png"/>
	<figcaption>Roassal</figcaption>
</figure>
</p>
<p>
At its core, Roassal offers a fine grained object-oriented model for displaying, interacting and animating graphs. On top of this model, Roassal offers several convenient builders for mapping arbitrary objects onto a drawable graph, the most known being the Mondrian builder.
</p>
<p>
To make visualization crafting easier, Moose offers tools to develop such visualizations. For example, the inspector  allows us to embed and preview visualizations directly. The picture below shows an example of a visualization script executed against a directory showing the nesting of all subdirectories in a circular treemap and highlighting the directories that contain a <code>build.xml</code> file.
</p>
<figure><pre><code>b := RTCircularTreeMapBuilder new.
b shape
  borderColor: Color lightGray;
  if: [ :d | 
    d files anySatisfy: [ :f |
      f basename = 'build.xml' ] ]   color: [ Color red ].
b leafWeight: [:f | f size sqrt ];
  explore: self
  nesting: #directories
  leaves: #directories.
b </code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/roassal-2.png"/>
	<figcaption>Roassal in the inspector</figcaption>
</figure>
</p>
<p>
The script is rather compact. Furthermore, you do not even have to write the complete script at once. Instead, you can preview the state of the visualization after each modification. Thus, you can iterate easily until you reach an acceptable result.
</p>
<p>
These visualizations are fully interactive, and developers can continue inspecting the objects behind the visual representations. This is particularly relevant for supporting iterative analyses.
</p>
<p>
You can learn more about Roassal in <a href="http://www.agilevisualization.com">the Agile Visualization book</a>.
</p>
<h3 id="h3glamour">Glamour</h3>

<p>
Visualizations are great, but analyzing complicated models requires browsing through multiple complementary views. To help you craft browsers fast and inexpensively, Moose comes with the Glamour browsing engine.
</p>
<p>

<figure>
	<img src="figures/glamour-workflow.png"/>
	<figcaption>Glamour</figcaption>
</figure>
</p>
<p>
The entire user interface of Moose is built with Glamour (yes, the pun is intended). For example, take a look at the code browser below. It shows a standard browser opened on a Java system.
</p>
<p>

<figure>
	<img src="figures/moose-code-browser.png"/>
	<figcaption>Sample browser</figcaption>
</figure>
</p>
<p>
The size of the code associated with this browser measures about 130 lines. This tiny compared with the functionality. For example, inside the same browser, you can scope the methods by the instance variables that they use, and you can navigate through the senders and implementors of a method. This is possible because Glamour is based on a novel model for capturing the essence of browsing at a higher level than that of user interface widgets.
</p>
<p>
The goal of Glamour is to let you build the workflow of a browser, while the more fancy rendering is delegated to other engines like Roassal. Glamour also comes with a dedicated editor that enables developers to test and preview their browsers.
</p>
<p>
For example, the picture below shows a browser that lets you query or select classes from a list, and preview their interaction as a System Attraction visualization. The browser is generated with the script at the bottom and previewed on top.
</p>
<figure><pre><code>composer tabulator with: [ :t |
	t column: #list; column: #map.	
	t transmit to: #list; andShow: [ :a |
		a list
			beMultiple;
			showOnly: 100;
			format: #mooseDisplayString;
			withSmalltalkSearch ].
	t transmit from: #list; to: #map; andShow: [:a :selected |
		a roassal2
			initializeView: [ RTMondrian new ];
			painting: [:view |
				FAMIXSystemAttraction new view: selected on: view ] ] ].
composer startOn: classGroup.</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/glamour-editor.png"/>
	<figcaption>Glamour Editor</figcaption>
</figure>
</p>
<p>
Perhaps interesting to note is that the editor itself was built with Glamour, too. Or the Finder interface that you can see below was also written in Glamour in a couple of hundreds of lines of code.
</p>
<p>
Browsers are important tools for understanding complicated models. Glamour makes the construction of such browsers inexpensive. You can learn more about Glamour in <a href="http://www.themoosebook.org/book/internals/glamour">the dedicated chapter from the Moose Book</a>.
</p>
<h3 id="h3finder">Finder</h3>

<p>
All these engines can be combined in various forms. One interface in which most of them come together is the Moose Finder, the basic browser meant to help you navigate through models.
</p>
<p>

<figure>
	<img src="figures/finder-workflow.png"/>
	<figcaption>Finder</figcaption>
</figure>
</p>
<p>
The browser is based on Glamour. To cope with any model, it generates dynamically the navigation paths based on Fame descriptions (for example, when selecting a class you can navigate to its methods). It also includes multiple Roassal-based visualizations that are specific to each entity type. Also, for color displaying source code with syntax highlighting, it uses a PetitParser-based parser.
</p>
<p>
For example, the screenshot below shows the finder open on a group of classes from a Java system. The pane to the right shows the result of the query entered at the bottom (<code>each annotationTypes notEmpty</code> retrieves all classes that have at least one class-level annotation). Furthermore, the preview is shown highlighted on a System Nesting Map.
</p>
<p>

<figure>
	<img src="figures/finder-query-visualization.png"/>
	<figcaption>Finder with a  query and a visualization</figcaption>
</figure>
</p>
<p>
Selecting one of the classes from the map, spawns another pane to the right. In our case, the browser shows the source code of the selected class with syntax highlighting.
</p>
<p>

<figure>
	<img src="figures/finder-visualization-source.png"/>
	<figcaption>Finder with a visualization and source code</figcaption>
</figure>
</p>
<p>
The Moose Finder focuses on the iterative nature of analysis. Every instance of the browser captures one analysis flow where every pane represents a step in the analysis. This is particularly useful when the analysis requires multiple steps. Furthermore, the Finder is extensible, and developers can easily add presentations specific to their entities.
</p>
<h3 id="h3theglamoroustoolkit">The Glamorous Toolkit</h3>

<p>
Moose is primarily an analysis platform. This means that the editing part is not particularly supported for external languages. However, the lessons from Moose should be more closely embedded inside the IDE (integrated development environment). For Pharo, this happens through the Glamorous Toolkit (<a href="http://gtoolkit.org">gtoolkit.org</a>). The core concept of the toolkit is the idea of moldability, a property that allows engineers to adapt development tools inexpensively to deal with contextual problems. We have already seen in the examples above how the Playground and the Inspector can help us work with arbitrary objects. Similarly, we can also use Spotter, the search interface. In the figure below we can see a search through the entities of a Java code model.
</p>
<p>

<figure>
	<img src="figures/spotter-model-search.png"/>
	<figcaption>Using Spotter to search through the Model</figcaption>
</figure>
</p>
<h3 id="h3otherenginesandtools">Other engines and tools</h3>

<p>
The engines and tools mentioned above are the most visible one that come with Moose. Yet, Moose offers more. To name a few:
</p><ul>
<li>Arki for building reports;</li>
<li>MooseAlgos for expressing various algorithms related to data mining, graphs or traversals;</li>
<li>SmaCC parsing framework;</li>
<li>XML, JSON, CSV support;</li>
<li>Metanool for handling custom annotations on entities;</li>
<li>Multiple off-the-shelf dedicated browsers, software metrics and visualizations.</li>
</ul>

<h2 id="h2summary">Summary</h2>

<p>
Moose is a platform that is made for programmers. It provides engines to express those analyses, and a rich development environment to actually craft them.
</p>
<p>
Working with Moose does imply a learning curve. However, this investment is worthwhile from two perspectives:
</p><ol><li>Moose aims to be versatile enough so that you can address multiple scenarios with it. Its most obvious target is the analysis of source code models. However, the same tools can be used to reason about any objects, too.</li>
<li>Moose makes <a href="http://humane-assessment.com">humane assessment</a> possible by bringing the cost of crafting custom tools close to zero. When tools cost almost nothing, the activity of humans can change dramatically.</li>
</ol>

<p>
But, Moose is more than the source code. It is also an active and open community. If you want to give it a try, just <a href="http://www.moosetechnology.org">join us</a>. Work with us. Play with us. Software engineering is still young and there are plenty of things to uncover.
</p>
<p class="note">If someone asks, you can say that Moose is all about custom analyses made easy.</p>








<h1 id="h1importingandexportingmodels">Importing and exporting models</h1>
<p>
The first step in the process of analysis is the generation of a model of a given target system or set of data. Moose can handle multiple types of data and data sources. This chapter provides a short guide for how to deal with these.
</p>

<h2 id="h2importingandexportingwithmse">Importing and exporting with MSE</h2>
<p>
The preferred way to load a model in Moose is via an MSE file.
To load an MSE file, all you have to do is to press the ``Import from MSE'' button in the Moose Panel and indicate the file to load. This creates a model, populates it with the entities from the file and adds the model to the repository. Visually, the model appears in the list of models from the Moose Panel.
</p>
<p>
But what exactly is MSE? MSE is the default file format supported by Moose. It is a generic file format and can describe any model. It is similar to XML, the main difference being that instead of using verbose tags, it makes use of parentheses to denote the beginning and ending of an element.
</p>
<p>
The following snippet provides an example of a small model:
</p>
<figure><pre><code>( (FAMIX.Namespace (id: 1)
    (name 'aNamespace'))
  (FAMIX.Package (id: 201)
    (name 'aPackage'))
  (FAMIX.Package (id: 202)
    (name 'anotherPackage')
    (parentPackage (ref: 201)))
  (FAMIX.Class (id: 2)
    (name 'ClassA')
    (container (ref: 1))
    (parentPackage (ref: 201)))
  (FAMIX.Method
    (name 'methodA1')
    (signature 'methodA1()')
    (parentType (ref: 2))
    (LOC 2))
  (FAMIX.Attribute 
    (name 'attributeA1')
    (parentType (ref: 2)))
  (FAMIX.Class (id: 3)
    (name 'ClassB')
    (container (ref: 1))
    (parentPackage (ref: 202)))
  (FAMIX.Inheritance
    (subclass (ref: 3))
    (superclass (ref: 2))))</code></pre><figcaption></figcaption></figure>

<p>
The file defines 8 entities: 1 Namespace, 2 Packages, 2 Classes, 1 Method, 1 Attribute and 1 Inheritance. For each of these entities it provides a unique identifier (e.g., <code>(id: 1)</code>) and it defines properties. In general, properties can be either primitive, like <code>(name 'aNamespace')</code>, or they can point to another entity, like in the case of <code>(container (ref: 1))</code> which denotes that the container property of ClassA points to the instance of Namespace named aNamespace.
</p>
<p>
The overall object graph can be seen graphically below.
</p>
<p>

<figure>
	<img src="figures/mse-graph.png"/>
	<figcaption>MSE example</figcaption>
</figure>
</p>
<p>
A more complex MSE example is available for download as described in <a href=""></a>.
</p>
<p>
Once a model is loaded, it can be easily exported as an MSE file. This can be done via the contextual menu of the model. By choosing the ``Export to MSE'' menu item you will be prompted to indicate the desired file name and location, and the result is an MSE file saved on the disk containing the entities in the model.
</p>
<h2 id="h2importingpharocode">Importing Pharo code</h2>
<p>
Moose comes with a built-in importer for Pharo code. The prerequisite for using this importer is that you first need the target source code present in the Pharo image.
</p>
<p>
Once the code is present, simply press on the ``Load from Pharo'' item from 
the menu of the Moose Panel, and follow the steps from the opening wizard.
</p>
<p class="note">This importer works out of the box for code built for Pharo. For code written in other Smalltalk dialects, the code must first be made loadable into Pharo. Moose does not offer ready made solutions for these other languages, but for most known dialects, like VisualWorks, you can often find solutions for exporting the code in a file format loadable in Pharo. An important note is that the code does not have to be fully functioning. It merely needs to be loadable in the Pharo image.</p>

<h2 id="h2importingjavacode">Importing Java code</h2>
<p>
Moose supports the analysis of Java systems by means of external parsers and MSE file for model interchange. The general process can be seen in the picture below.
</p>
<p>
The first step is to use the external parser to process the Java sources. Afterwards, the external tool exports the model in MSE. And finally, this MSE file is imported in Moose.
</p>
<p>

<figure>
	<img src="figures/importing-external.png"/>
	<figcaption>Importing with external parser</figcaption>
</figure>
</p>
<p>
jdt2famix is an exporter that produces MSE files out of Java code. It is based on JDT Core and Fame for Java, and it requires Java 8. More information, including instructions of how to use it can be found on the main page: <a href="https://github.com/girba/jdt2famix">https://github.com/girba/jdt2famix</a>.
</p>
<p class="todo">example</p>

<h2 id="h2settingtherootfolder">Setting the root folder</h2>
<p>
To be able to access the source text of a model imported from MSE, we first need to locate this source text. However, models do not typically contain source text representation. Instead the source is stored in external files, and Moose needs to learn the location of these files so that it can display and manipulate the source.
</p>
<p>
For example, after importing a Java system with inFusion, we get just the MSE file and we need to reconcile it with the actual sources. You can achieve this for any model by invoking from its contextual menu: Utilities/Set root folder.
</p>
<p>
Another way to achieve the reconciliation between the MSE file and the sources is to place the sources in the default root folder for the model which is a folder with the same name as the model placed under a <code>src</code> folder inside the folder containing the <code>moose.image</code> file. For example, for the ArgoUML running example, you should place the contents of the ArgoUML folder under the following folder:
</p>
<figure><pre><code>/
  moose.image
  moose.changes
  src/
    ArgoUML-0-34/</code></pre><figcaption></figcaption></figure>

<h1 id="h1writingparserswithpetitparser">Writing parsers with PetitParser</h1>
<p>
Pre-existing parsers and importers allow us to deal with well-known languages and data formats. However, in many situations we have to reason about systems written in custom languages or formats.
</p>
<p>
In such situations we need to have the possibility of specifying custom parsers. Moose comes with PetitParser, a parsing framework that enables us to build custom parsers easily.
</p>
<p>
This chapter covers this framework. We start with a hands-on tutorial (see <a href=""></a>), and then we move on to looking into the overall design and the various components.
</p>

<h2 id="h2stepbystepparsingofmse">Step by step parsing of MSE</h2>
<p>
To show how PetitParser works, we take as case study creating a parser to manipulate MSE files. That is right: we pretend Moose has no infrastructure for handling MSE files and we have to create one from scratch.
</p>
<p>
The only input we consider is the official grammar of MSE given using the following rules:
</p>
<figure><pre><code>Root := Document ?
Document := OPEN ElementNode * CLOSE
ElementNode := OPEN ELEMENTNAME Serial ? AttributeNode * CLOSE
Serial := OPEN ID NATURAL CLOSE
AttributeNode := OPEN SIMPLENAME ValueNode * CLOSE
ValueNode := Primitive | Reference | ElementNode
Primitive := STRING | NUMBER | Boolean
Boolean := TRUE | FALSE
Reference := IntegerReference | NameReference
IntegerReference := OPEN REF NATURAL CLOSE
NameReference := OPEN REF ELEMENTNAME CLOSE</code></pre><figcaption></figcaption></figure>

<figure><pre><code>OPEN := &quot;(&quot;
CLOSE := &quot;)&quot;
ID := &quot;id:&quot;
REF := &quot;ref:&quot;
TRUE := &quot;true&quot;
FALSE := &quot;false&quot;
ELEMENTNAME := letter ( letter | digit ) * ( &quot;.&quot; letter ( letter | digit ) * ) 
SIMPLENAME := letter ( letter | digit ) *
NATURAL := digit +
NUMBER := &quot;-&quot; ? digit + ( &quot;.&quot; digit + ) ? ( ( &quot;e&quot; | &quot;E&quot; ) ( &quot;-&quot; | &quot;+&quot; ) ? digit + ) ?
STRING := ( &quot;'&quot; [^'] * &quot;'&quot; ) +</code></pre><figcaption></figcaption></figure>

<figure><pre><code>digit := \[0-9] 
letter := \[a-zA-Z_]
comment := &quot;&quot;&quot; [^&quot;] * &quot;&quot;&quot;</code></pre><figcaption></figcaption></figure>

<p>
Based on this, we first want to define a grammar to be able to read the file (see <a href=""></a>, <a href=""></a>, <a href=""></a> and <a href=""></a>). Once able to read, we learn how to test the grammar (see <a href=""></a>), and how to build a parser that produces a better output (see <a href=""></a>).
</p>
<p>
Further examples can be found at:
</p><ul>
<li><a href="http://www.lukas-renggli.ch/blog/petitparser-1/">http://www.lukas-renggli.ch/blog/petitparser-1/</a></li>
<li><a href="http://www.lukas-renggli.ch/blog/petitparser-2/">http://www.lukas-renggli.ch/blog/petitparser-2/</a></li>
</ul>


<h3 id="h3startingsmallwithparsingnames">Starting small with parsing names</h3>
<p>
As a first task, we parse the identifier names. Looking closely at the MSE grammar, we can find two distinct definitions for identifier names:
</p>
<figure><pre><code>ELEMENTNAME := letter ( letter | digit ) * ( &quot;.&quot; letter ( letter | digit ) * )
SIMPLENAME := letter ( letter | digit ) *</code></pre><figcaption></figcaption></figure>

<p>
Let's start with <code>SIMPLENAME</code>. The grammar definition says that a valid name must start with a letter, and afterwards it can be followed by either a letter or a digit repeated multiple times. The same specification can be represented graphically:
</p>
<p>

<figure>
	<img src="figures/petitparser-mse-simple-workflow.png"/>
	<figcaption>MSE workflow</figcaption>
</figure>
</p>

<p>
The translation to PetitParser looks like:
</p>
<figure><pre><code>simpleName := #letter asParser , ( #letter asParser / #digit asParser ) star.</code></pre><figcaption></figcaption></figure>

<p>
It is that easy. It reads almost like the abstract grammar. In essence, the grammar production is mapped on a parser object, and in this case we store it in the <code>simpleName</code> variable. The parser object is obtained out of terminal parser objects such as <code>#letter asParser</code> for parsing one letter character, or <code>#digit asParser</code> for parsing one digit character. These terminal parsers are composed using operators like <code>,</code> (sequence), <code>/</code> (choice) or <code>star</code> (zero or many). The result is a composite parser whose structure is a graph of objects.
</p>
<p>

<figure>
	<img src="figures/petitparser-mse-simple-objects.png"/>
	<figcaption>MSE objects</figcaption>
</figure>
</p>
<p>
To test our parser we pass it an input string via the <code>parse:</code> method:
</p>
<figure><pre><code>simpleName parse: 'ValidName'.  &quot;--&gt; #($V #($a $l $i $d $N $a $m $e))&quot;</code></pre><figcaption></figcaption></figure>

<p>
If we print the result we obtain a rather strange looking array that contains each individual character of the input string. We deal with the manipulation of the result at a later time. Currently, we declared ourselves satisfied with getting a valid result.
</p>
<p>
How do we recognize a valid response from an invalid one? Let's give it a try by passing an invalid name:
</p>
<figure><pre><code>simpleName parse: '1InvalidName'. &quot;--&gt;  letter expected at 0&quot;</code></pre><figcaption></figcaption></figure>

<p>
If we inspect the result, we obtain an instance of <code>PPFailure</code>, which denotes that the parser was not successful in parsing the input. If we only want to test the success of parsing, then we can also use the <code>match:</code> method:
</p>
<figure><pre><code>simpleName match: 'ValidName'.  &quot;--&gt; true&quot;
simpleName match: '1InvalidName'.  &quot;--&gt; false&quot;</code></pre><figcaption></figcaption></figure>

<p>
Having simple name sorted out, we can tackle <code>ELEMENTNAME</code>. It looks slightly more complex and it requires us to specify an optional part that can follow after a dot character. We approach it like we did before and by translating the abstract grammar notation into the PetitParser API.
</p>
<figure><pre><code>elementName := #letter asParser , ( #letter asParser / #digit asParser ) star , 
               (
                 $. asParser , 
                 #letter asParser , ( #letter asParser / #digit asParser ) star
               ) optional.</code></pre><figcaption></figcaption></figure>

<p>
The optional part is specified by simply sending <code>optional</code> to the corresponding parser. Furthermore, to parse the dot character we use <code>$. asParser</code>.
</p>
<p>
At a closer look, we notice the duplication in the above definition. The first part that covers the input until the optional dot is repeated inside the optional part. We could factor it out. Actually, we already have it in <code>simpleName</code>, and we can reuse it:
</p>
<figure><pre><code>elementName := simpleName , ($. asParser , simpleName) optional.</code></pre><figcaption></figcaption></figure>

<p>
We can test it:
</p><figure><pre><code>elementName matches: 'Valid.Name'. &quot;--&gt; true&quot;
elementName matches: '1InvalidName.' &quot;--&gt; false&quot;</code></pre><figcaption></figcaption></figure>


<h3 id="h3manipulatingtheoutputofparsingstringsandnumbers">Manipulating the output of parsing strings and numbers</h3>
<p>
Let us now tackle the parsing of MSE srings and numbers. Valid strings start and end with a single quote character, and in between we should have any non single-quote character:
</p>
<figure><pre><code>STRING := ( &quot;'&quot; [^'] * &quot;'&quot; ) +</code></pre><figcaption></figcaption></figure>

<p>
The tricky part is expressing <em>any character except</em>. This is achieved through <code>negate</code>. We specify our parser through a sequence in which the contents of the string are given by the parser of single-quote negated and repeated multiple times:
</p>
<figure><pre><code>string := $' asParser , 
          $' asParser negate star ,
          $' asParser.</code></pre><figcaption></figcaption></figure>

<p>
A more challenging task would be to add support for escape characters. For example, in MSE, it is allowed to have the character single-quote if it is escaped by another single-quote. The parser could be written as:
</p>
<figure><pre><code>string := $' asParser , 
          ('''''' asParser / $' asParser negate) star ,
          $' asParser.</code></pre><figcaption></figcaption></figure>

<p>
The parser now says that either we have two single-quotes one after the other or we do not have any single-quote.
</p>
<p>
Why are there six single-quotes? This happens because the code is written in Smalltalk, and in Smalltalk strings are also marked with single-quotes. For this reason we have two single-quotes surrounding the Smalltalk string, and inside we need to escape the two single-quotes with two more as required by Smalltalk. In total, we get six.
</p>
<p>
We can test the code:
</p>
<figure><pre><code>string parse: '''string'''.  &quot;--&gt; #($' #($s $t $r $i $n $g) $')&quot;
string parse: '''qu''''ote'''.  &quot;--&gt; #($' #($q $u '''''' $o $t $e) $')&quot;</code></pre><figcaption></figcaption></figure>

<p>
The grammar works fine, but the result we obtain is less useful. PetitParser has two major responsibilities: to consume the input according to a grammar, and to transform it into a desired output. Given that the consuming boils down to a traversal of an input stream, the default result is nothing but a nested collection, where the nesting mirrors the specified grammar. For example, <code>#($' #($s $t $r $i $n $g) $')</code> is a Smalltalk array with three elements:
</p><ul>
<li><code>$'</code>, </li>
<li><code>($s $t $r $i $n $g)</code> which is a nested array produced by <code>star</code>, and</li>
<li><code>$'</code>.</li>
</ul>

<p>
Let us produce a more convenient output in the form of a regular Smalltalk string. First, we want the second element in the resulting array to not be an array but directly a flatten string. For this we have a convenient <code>flatten</code> operator.
</p>
<figure><pre><code>string := $' asParser , 
          ('''''' asParser / $' asParser negate) star flatten ,
          $' asParser.</code></pre><figcaption></figcaption></figure>

<p>
The new result looks better:
</p>
<figure><pre><code>string parse: '''string'''.  &quot;--&gt; #($' 'string' $')&quot;</code></pre><figcaption></figcaption></figure>

<p>
Ultimately, we would want our little parser to ignore the first and the last element and return only the second one. For this, PetitParser offers the possibility to specify a custom transformation through the <code>==&gt;</code> operator:
</p>
<figure><pre><code>string := ($' asParser , 
          ('''''' asParser / $' asParser negate) star flatten ,
          $' asParser)
          ==&gt; [ :token | token second ].</code></pre><figcaption></figcaption></figure>

<p>
The transformation operator can be applied to any parser and it takes a block with one argument. The value of the argument is given by the default result of the current parser.
</p>
<p>
In our case, the token argument holds the array <code>#($' 'string' $')</code> and we simply say we want to return the second element. The result is finally what we want:
</p>
<figure><pre><code>string parse: '''string'''. &quot;--&gt; 'string'&quot;</code></pre><figcaption></figcaption></figure>

<p>
Now, let us move on and create a parser for numbers that produces Smalltalk numbers. For the simplicity of the discussion, let us focus on a smaller grammar:
</p>
<figure><pre><code>NATURAL := digit +
NUMBER := &quot;-&quot; ? digit + ( &quot;.&quot; digit + ) ?</code></pre><figcaption></figcaption></figure>

<p>
The correspondent parser can look like:
</p>
<figure><pre><code>natural := #digit asParser plus.
number  := ($- asParser optional , natural , ($. asParser , natural) optional).</code></pre><figcaption></figcaption></figure>

<p>
While the above parser is a direct translation of the grammar definition, we can decompose it better to make the several parts more explicit:
</p>
<figure><pre><code>natural        := #digit asParser plus. 
decimalPart    := ($. asParser , natural).
positiveNumber := natural , decimalPart optional.
negativeNumber := $- asParser , positiveNumber. 
number         := positiveNumber / negativeNumber.</code></pre><figcaption></figcaption></figure>

<p>
In the end, we want to produce a number. To achieve this we use the transformation blocks for each parser. 
</p>
<figure><pre><code>natural        := #digit asParser plus flatten 
                  ==&gt; [:token | token asNumber].
decimalPart    := ($. asParser , natural) 
                  ==&gt; [:token | (token at: 2) * (10 raisedTo: (0- (token at: 2) asString size)) asFloat ].
positiveNumber := natural , decimalPart optional 
                  ==&gt; [:token | (token at: 1) + ((token at: 2) ifNil: [0]) ].
negativeNumber := $- asParser , positiveNumber 
                  ==&gt; [:token | 0 - (token at: 2)] .
number         := positiveNumber / negativeNumber.</code></pre><figcaption></figcaption></figure>

<p>
We start with the <code>natural</code> parser and simply use the <code>asNumber</code> method available in a Smalltalk string that transforms the contents of the string into a number. From this point on, when the <code>natural</code> parser is used, the output will always be a Smalltalk number, and not a string anymore. Using this approach we can build up the result out of fine grained pieces.
</p>
<p>
One thing to notice is what happens with an optional part. For example, the <code>positiveNumber</code> has an optional <code>decimalPart</code>. This means that if the decimal part is available, the second element in the token array will hold the value of applying the <code>decimalNumber</code> parser to the input, but if the decimal part is missing, the corresponding value will be <code>nil</code>. Thus, we typically have to guard the manipulation of an optional part with an if in the transformation block. In our case, we want <code>0</code> when no decimal part is specified.
</p>
<p>
One way to go around the use of an optional is to use the choice parser combinator (i.e., <code>/</code>). For example, even if in the original grammar there are two optional productions (i.e., one for the sign, and one for the decimal part) in the transformation blocks we have only one if. This happens because we modeled the optional sign in a <code>number</code> with a choice between a <code>positiveNumber</code> and a <code>negativeNumber</code>. While both approaches can have their benefits, it is important to know of their existence and choose the one that better fits the problem at hand.
</p>

<h3 id="h3dealingwithcyclicdependencieswhenscriptingthemsegrammar">Dealing with cyclic dependencies when scripting the MSE grammar</h3>
<p>
In <a href=""></a> we see in details how we approach the definition of parsers to deal with the names. Once the grammar is clear, the process is straightforward and can be repeated for any production rules.
</p>
<p>
The full MSE parser can be seen below.
</p>
<figure><pre><code>open := $( asParser trim.
close := $) asParser trim.
string := ($' asParser , 
          ('''''' asParser / $' asParser negate) star flatten ,
          $' asParser) trim.
natural := #digit asParser plus flatten.
e :=  ($e asParser / $E asParser) , ($- asParser / $+ asParser) optional , natural.
number := ($- asParser optional , natural , 
          ($. asParser , natural , e optional) optional) flatten trim.
boolean := ('true' asParser / 'false' asParser) flatten trim.
primitive := string / number / boolean.
simpleName := #word asParser star flatten.
elementName := (simpleName , ($. asParser , simpleName) optional) token trim.
nameReference := (open , 'ref:' asParser , elementName , close) token.
integerReference := (open , 'ref:' asParser , natural trim , close) token.
reference := integerReference / nameReference.
element := PPUnresolvedParser new.
attributeValue := (primitive / reference / element) star.
attribute := (open , simpleName , attributeValue , close) trim.
id := (open , 'id:' asParser , natural trim , close) trim.
element def: ( (open , elementName , id optional , attribute star , close) trim).
elements := open , element star , close.
start := elements end.</code></pre><figcaption></figcaption></figure>

<p>
You can test the parser with a valid MSE string:
</p><figure><pre><code>mseString := '(
  (FAMIX.Package 
     (name ''PackageP''))
  (FAMIX.Class
     (name ''ClassA''))
  (FAMIX.Method
     (name ''methodM''))
)'.
start parse: mseString</code></pre><figcaption></figcaption></figure>


<p>
A particularity of this example is the use of PPUnresolvedParser. When scripting a grammar, every production is held in a parser variable. However, in our case, we have cyclic definitions: 
</p><ul>
<li>the <code>element</code> parser depending on the <code>attributeValue</code> parser (through <code>attribute</code>), and</li>
<li>the <code>attributeValue</code> parser depending on the <code>element</code> one.</li>
</ul>

<p>
This is the case where PPUnresolvedParser comes to the rescue. We first define one of the parser as undefined, refer to it from the second parser, and then we define the first rule using <code>def:</code>.
</p>
<p>
This example provides a good coverage of the various operators available in PetitParser. More detailed information about these can be found in <a href=""></a>.
</p>

<h3 id="h3encapsulatingthemsegrammarinaclass">Encapsulating the MSE grammar in a class</h3>
<p>
Scripting a parser is fast, but it can also get dirty. In fact, for any parser that has more than a handful of sub-parsers, it typically gets too dirty.
</p>
<p>
To solve the situation, PetitParser also offers the possibility of mapping a parser on a class. The idea is quite simple:
</p><ul>
<li>the class must be a subclass of <code>PPCompositeParser</code>, and it holds the complete parser,</li>
<li>the methods of the class provide the productions, and</li>
<li>the attributes of the class store the actual sub-parsers.</li>
</ul>

<p>
Let us take our example of producing an MSE grammar. We first create the class.
</p>
<figure><pre><code>PPCompositeParser subclass: #ExampleMSEGrammar
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'MSEParserExample'</code></pre><figcaption></figcaption></figure>

<p>
Afterwards, we take each production from the script and we transform it in a method. For example:
</p>
<figure><pre><code>start := elements end.</code></pre><figcaption></figcaption></figure>

<p>
gets transformed into:
</p>
<figure><pre><code>start 
  ^ elements end</code></pre><figcaption></figcaption></figure>

<p>
This might look odd at first sight. Indeed, there is a little magic going on behind the scene. Let us take a closer look.
</p>
<p>
For every production, we create a method. In this case we create the <code>start</code> method, which happens to be mandatory for telling the parser from which production it should start by default.
</p>
<p>
The odd thing is that in the method we refer directly to the <code>elements</code> production via an instance variable (i.e., instead of calling a method). This happens because the PPCompositeParser uses reflection to lookup the corresponding method and to store the result in the instance variable. This leads to a better performance when the same production is used in two different places.
</p>
<p>
Given that we now refer to the <code>elements</code> instance variable, we also have to create the corresponding method. To do this, we simple copy the production from the script:
</p>
<figure><pre><code>elements
  ^ open , element star , close.</code></pre><figcaption></figcaption></figure>

<p>
Repeating these steps for all the productions from the script, we obtain our grammar class. Afterwards, we can execute a parsing command via:
</p>
<figure><pre><code>mseString := '(
  (FAMIX.Package (id: 1) 
     (name ''PackageP''))
  (FAMIX.Class (id: 2) 
     (name ''ClassA'')
     (parentPackage (ref: 1)))
  (FAMIX.Method (id: 3)
     (name ''methodA'')
     (declaredType (ref: 1))
     (parentType (ref: 2)))
)'.
ExampleMSEGrammar parse: mseString</code></pre><figcaption></figcaption></figure>


<h3 id="h3testingthemsegrammarclass">Testing the MSE grammar class</h3>
<p>
Parsers can get complex quite quickly. For example, the MSE grammar developed previously (see <a href=""></a>) even if rather small, it is reasonably intricate as can be seen in the graph below:
</p>
<p>

<figure>
	<img src="figures/petitparser-mse-grammar-graph.png"/>
	<figcaption>MSE Grammar</figcaption>
</figure>
</p>
<p>
In this situation testing becomes central for controlling the evolution of the parser. Given its importance, PetitParser offers a dedicated infrastructure similar to the one for creating parsers.
</p>
<p>
To create a test case, we first create a subclass of PPCompositeParserTest:
</p>
<figure><pre><code>PPCompositeParserTest subclass: #ExampleMSEGrammarTest
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'MSEParserExample'</code></pre><figcaption></figcaption></figure>

<p>
In this test class, we override the <code>parserClass</code> method to return the target parser to be tested:
</p>
<figure><pre><code>ExampleMSEGrammarTest&gt;&gt;parserClass
  ^ ExampleMSEGrammar</code></pre><figcaption></figcaption></figure>

<p>
Afterwards, each test method should be focused on testing one example for one production. For writing the assertion, the base test class offers a utility <code>parse:rule:</code> that checks that the string passed as the first argument is parse-able using the production passed as the second argument. For example, for testing the element name we can write:
</p>
<figure><pre><code>ExampleMSEGrammarTest&gt;&gt;testElementName
  self parse: 'ABC.XYZ' rule: #elementName</code></pre><figcaption></figcaption></figure>


<h3 id="h3creatinganmseparser">Creating an MSE parser</h3>
<p>
The grammar provides a means to digest the input from a syntactic point of view. The default result of parsing the input using this grammar is an array. In most cases this array is not at all satisfactory. Instead, we need to produce an output that matches our problem.
</p>
<p>
Let us consider using the MSE grammar from <a href=""></a> for a simple input.
</p>
<figure><pre><code>mseString := '((FAMIX.Package))'.
ExampleMSEGrammar parse: mseString.
&quot;--&gt;  an Array($( an Array(an Array($( a PPToken(FAMIX.Package) nil #() $))) $))&quot;</code></pre><figcaption></figcaption></figure>

<p>
Let us supposed that we merely want to produce a regular Smalltalk nested array out of input. There is a lot of unwanted cruft that we would like to get rid of, such as not printing <code>a PPToken</code> explicitly, but only get the name of the element.
</p>
<p>
To solve this problem, we subclass the grammar class with a parser class that will take care of the desired transformation.
</p>
<figure><pre><code>ExampleMSEGrammar subclass: #ExampleMSEArrayParser
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'MSEParserExample'</code></pre><figcaption></figcaption></figure>

<p>
Before we go any further, we write a test. To do this we mirror the hierarchy of parsers with a hierarchy of tests:
</p>
<figure><pre><code>ExampleMSEGrammarTest subclass: #ExampleMSEArrayParserTest
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'MSEParserExample'</code></pre><figcaption></figcaption></figure>

<figure><pre><code>ExampleMSEArrayParserTest&gt;&gt;testElementName
  super testElementName.
  self assert: result = 'ABC.XYZ'</code></pre><figcaption></figcaption></figure>

<p>
The first line, simply calls the test defined in the super class (see <a href=""></a>). Because the test stores the parsing result result in the <code>result</code> instance variable, we can use this instance variable for writing the assertion.
</p>
<p>
The test fails as expected. To make it work, we now have to override the <code>elementName</code> definition in the parser class and specify how the output should be transformed:
</p>
<figure><pre><code>ExampleMSEArrayParser&gt;&gt;elementName
  ^ super elementName

  ==&gt; [:token | token value ]</code></pre><figcaption></figcaption></figure>

<p>
The output transformation is achieved through the <code>==&gt;</code> operator. This operator takes as input the value returned by the parser and returns the result of evaluating the block. In this case, we simply want to extract the string value out of the token object.
</p>
<p>
With this change, the test becomes green, and running the example yields:
</p>
<figure><pre><code>mseString := '((FAMIX.Package))'.
ExampleMSEArrayParser parse: mseString.
&quot;--&gt;  an Array($( an Array(an Array($(FAMIX.Package nil #() $))) $))&quot;</code></pre><figcaption></figcaption></figure>


<h2 id="h2parsingoperators">Parsing operators</h2>
<p>
PetitParser is based on scannerless parsing. This means that even the most basic of parsers are parsers too. PetitParser offers several of these basic parsers, also called terminals. Here are some examples:
</p>
<table style="border: solid thin"><tr><th>Terminals</th>
<th>Description</th>
</tr>
<tr><td><code>$a asParser</code></td>
<td>Parses the character $a.</td>
</tr>
<tr><td><code>'abc' asParser</code></td>
<td>Parses the string 'abc'.</td>
</tr>
<tr><td><code>#any asParser</code></td>
<td>Parses any character.</td>
</tr>
<tr><td><code>#digit asParser</code></td>
<td>Parses the digits 0..9.</td>
</tr>
<tr><td><code>#letter asParser</code></td>
<td>Parses the letters a..z and A..Z.</td>
</tr>
<tr><td><code>#cr asParser</code></td>
<td>Parses the carriage-return character.</td>
</tr>
<tr><td><code>#lf asParser</code></td>
<td>Parses the line-feed character.</td>
</tr>
<tr><td><code>#space asParser</code></td>
<td>Parses the space character.</td>
</tr>
<tr><td><code>#tab asParser</code></td>
<td>Parses the tabulator character.</td>
</tr>
<tr><td><code>nil asParser</code></td>
<td>The empty parser.</td>
</tr>
</table>

<p>
More readily available terminals can be found on the class side of the <code>PPPredicateObjectParser</code> class, in the <code>factory-chars</code> protocol.
</p>
<table style="border: solid thin"><tr><th>Combinators</th>
<th>Description</th>
</tr>
<tr><td><code>p1 , p2</code></td>
<td>Parses p1 followed by p2 (sequence).</td>
</tr>
<tr><td><code>p1 / p2</code></td>
<td>Parses p1, if that doesn’t work parses p2 (ordered choice).</td>
</tr>
<tr><td><code>p star</code></td>
<td>Parses zero or more p.</td>
</tr>
<tr><td><code>p plus</code></td>
<td>Parses one or more p.</td>
</tr>
<tr><td><code>p optional</code></td>
<td>Parses p if possible.</td>
</tr>
</table>

<table style="border: solid thin"><tr><th>Predicates</th>
<th>Description</th>
</tr>
<tr><td><code>p and</code></td>
<td>Parses p but does not consume its input.</td>
</tr>
<tr><td><code>p not</code></td>
<td>Parses p and succeeds when p fails, but does not consume its input.</td>
</tr>
<tr><td><code>p negate</code></td>
<td>Parses any input token but the receiver.</td>
</tr>
<tr><td><code>p end</code></td>
<td>Parses p and succeeds at the end of the input.</td>
</tr>
</table>

<p>
To manipulate the output of a parser, PetitParser offers actions that we can use to decorate the parser.
</p>
<table style="border: solid thin"><tr><th>Actions</th>
<th>Description</th>
</tr>
<tr><td><code>p ==&gt; aBlock</code></td>
<td>Performs the transformation given in aBlock.</td>
</tr>
<tr><td><code>p flatten</code></td>
<td>Creates a string from the result of p.</td>
</tr>
<tr><td><code>p token</code></td>
<td>Creates a token from the result of p.</td>
</tr>
<tr><td><code>p trim</code></td>
<td>Trims all whitespaces before and after p.</td>
</tr>
<tr><td><code>p trimBlanks</code></td>
<td>Trims the blanks before and after p.</td>
</tr>
</table>


<h2 id="h2dedicateduserinterface">Dedicated user interface</h2>
<p>
If you want to visualize, edit, or debug the parser, you can use the built-in editor by:
</p>
<figure><pre><code>PPBrowser open</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/petitparser-browser.png"/>
	<figcaption>PetitParser browser</figcaption>
</figure>
</p>
<h1 id="h1meta-modelingwithfame">Meta-modeling with Fame</h1>

<p>
Fame is the meta-modeling infrastructure of Moose. It provides the following features:
</p><ul>
<li>the FM3 self described meta-meta-model,</li>
<li>meta-description of regular implementation classes through annotations,</li>
<li>the MSE format for model interchange,</li>
<li>input/output serialization to the MSE format, and</li>
<li>generation of implementation classes from a meta-description.</li>
</ul>


<h2 id="h2thefm3meta-meta-model">The FM3 meta-meta-model</h2>
<p>
The core of Fame is given by the FM3 meta-meta-model. FM3 is a small meta-meta-model inspired from the Essential Meta-Object Facility.
</p>
<p>
All meta-models from Moose are described in terms of FM3.
</p>
<p>
More information about it can be found at: <a href="http://www.moosetechnology.org/tools/fame/">http://www.moosetechnology.org/tools/fame/</a>
</p>

<h2 id="h2subject,model,meta-model,meta-meta-model">Subject, model, meta-model, meta-meta-model</h2>
<p>
Often, the terms of model and meta-model generate confusion. As they are crucial for understanding the terminology related to modeling, let me spend a couple of words to clarify them.
</p>
<p>
Before talking about either of them, we first have to talk about the concept of a <em>subject</em>. A subject is simply something we want to reason about. It can be something from the real world, or something imaginary. For example, if we want to analyze a software system, that software system is the subject.
</p>
<p>
The act of reasoning is typically geared around one specific problem or question. The answer to the question typically only concerns a small subset of all the characteristics of the subject. Thus, the process of reasoning is greatly enhanced if we limit its scope to only the relevant variables.
</p>
<p>
For example, when we want to reason about the best path to get from point A to point B, we only require the route information, and we do not really need to know about other details like the quantity of oil in the ground, or the language spoken by the inhabitants. This is why for the purpose of route finding, we typically use a travel map which is a great tool that provides exactly the details we need to solve our little problem.
</p>
<p>
In general, to solve a problem we construct simplifications of the subject. We call these models. Bezivin and Gerbe define a model: a simplification of the subject, and its purpose is to answer some particular questions aimed towards the subject. In the case of Moose, FAMIX (see <a href=""></a>) is a family of meta-models for representing the structure of software projects.
</p>
<p>
Given that a model captures only a part of the complete subject, we can build many models that represent the same subject but that capture different variables of the subject. To reason about a model we need to know which exact variables it offers. In other words, we need to know the structure of the model. This information is expressed in the meta-model, where a meta-model is a model that makes statements about what can be expressed in valid models.
</p>
<p>
One common misconception is to say that <em>a meta-model is the model of a model</em>. That is incorrect. A model shows a simplification of a subject. A meta-model offers the vocabulary for formulating reasonings on top of a given model. While both are models, they are different in intent and interpretation.
</p>
<p>
Another form of the above misconception is formulated as: <em>the relationship between the model and subject is the same as the one between meta-model and model</em>. That is incorrect as well. While a model <em>represents</em> a subject, a meta-model <em>describes</em> a model.
</p>
<p>
Once we understand the difference between meta-model and model, we can go even deeper in the meta-land and add as many meta levels as we might need. The attached diagram shows an overall of four levels and their relationships.
</p>
<p>

<figure>
	<img src="figures/subject-model-meta-model-meta-meta-model.png"/>
	<figcaption>Subject, model, meta-model, meta-meta-model</figcaption>
</figure>
</p>

<p>
Why would we need more meta-levels? We always need a meta-level when we want to reason about the model at the level below. When we want to reason about a map, we need to know its structure. In the same way, when we want to reason about the structure of a map, we need to know the structure of the structure of the map. In Moose, we have a main meta-meta-model in terms of which we describe our meta-models: FM3 (see <a href=""></a>).
</p>

<h2 id="h2pharointegration">Pharo integration</h2>

<p class="todo">more</p>
<figure><pre><code>FAMIXPackage new class &quot;--&gt; FAMIXPackage&quot;</code></pre><figcaption></figcaption></figure>

<figure><pre><code>FAMIXPackage asMooseDescription &quot;--&gt;  a FM3MetaDescription[FAMIX.Package]&quot;</code></pre><figcaption></figcaption></figure>

<figure><pre><code>FAMIXPackage new mooseDescription &quot;--&gt;  a FM3MetaDescription[FAMIX.Package]&quot;</code></pre><figcaption></figcaption></figure>

<figure><pre><code>FAMIXPackage new mooseDescription implementingClass &quot;--&gt; FAMIXPackage&quot;</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/fame-pharo-integration.png"/>
	<figcaption>Fame integration with the Pharo meta-model</figcaption>
</figure>
</p>
<figure><pre><code>FAMIXPackage asMooseDescription attributes first implementingSelector &quot;--&gt; #numberOfMethods&quot;</code></pre><figcaption></figcaption></figure>

<ul>
<li><code>Object&gt;&gt;mmGetProperty: aFM3PropertyDescription</code></li>
<li><code>Object&gt;&gt;mmSetProperty: aFM3PropertyDescription to: value</code></li>
</ul>

<h1 id="h1thecoremeta-model">The core meta-model</h1>
<p>
The core of Moose offers support for storing and manipulating entities in models. The figure below provides an overview of the main classes involved:
</p><ul>
<li>Entity -- representing basic abstract entity representation,</li>
<li>Group -- representing a group of entities, and</li>
<li>Model-- a special group that contains all entities relevant for a system.</li>
</ul>

<p>
The following sections provide more details about each of these.
</p>
<p>

<figure>
	<img src="figures/moose-entity-model-group.png"/>
	<figcaption>Entity, Model, Group</figcaption>
</figure>
</p>

<h2 id="h2theentity">The Entity</h2>
<p>
The MooseEntity is the basic representation of an entity in a model. Thus, the MooseEntity class is meant to be subclassed by any specific meta-model entity.
</p>
<p>
It provides two main generic services.
</p>
<p>
First, it holds a reference to the parent MooseModel. This does lead to a cyclic dependency between the entity and the model. However, given the tight connection between these two concepts, it is unproblematic in practice while it provides a particularly handful feature for creating queries that require more information than the current entity provides. 
</p>
<p>
For example, suppose that we intend to create a query that given a method entity checks whether another method with the same name appears in the rest of the model. For this, we need to traverse all methods in the model. Having the reference to the model allows us to install a simple method without parameters (i.e., unary method) directly in FAMIXMethod:
</p>
<figure><pre><code>otherMethodsWithTheSameName
   ^ self mooseModel allMethods select: [:each | each name = self name]</code></pre><figcaption></figcaption></figure>

<p>
The second important feature of an entity is the mechanism for state management and extension achieved through the EntityState hierarchy.
</p>
<p>
Following our example, we might want to cache the result of <code>otherMethodsWithTheSameName</code> to not require a new traversal of all methods every time we ask for it. To achieve this, the simplest solution would be to add an instance variable to store the result. However,  extension methods like <code>otherMethodsWithTheSameName</code> are placed typically in a separate package (other than the package of the class), and thus the instance variable should also belong to the same package. This is not cleanly possible in Smalltalk.
</p>
<p>
EntityState solves the situation, by offering for each entity an extensible dictionary that simulates instance variables. For example, we could store the result of our query in a cache:
</p>
<figure><pre><code>otherMethodsWithTheSameName
   ^ self privateState 
       cacheAt: #otherMethodsWithTheSameName
       ifAbsentPut: [
         self mooseModel allMethods select: [:each | each name = self name]]</code></pre><figcaption></figcaption></figure>

<p>
Every entity can access its EntityState through the <code>privateState</code> message. There are three dictionaries offered:
</p><ul>
<li>attributes -- for variable extensions that are meant to extend the basic structure of the entity. This typically happens when we want to extend the meta-model with an extra relationship between two entities, we would store it as an attribute. For example, if you would have extra information about which author worked on which method, we could add an author attribute in the Method entity.</li>
<li>cache -- for storing the result of queries. For example, our example query is meant to be stored in the cache, and not as an attribute.</li>
<li>properties -- for storing simple values. For example, metrics are typically stored as properties.</li>
</ul>


<h2 id="h2thegroup">The Group</h2>
<p>
A Group is an entity representing a collection of entities. For example, we could have a group of class entities, a group of method entities.
</p>
<p>
Groups are important abstractions especially for queries and for user interfaces (see <a href=""></a>).
</p>
<p class="todo">storage</p>
<p class="todo">caches and allWithType:</p>
<p class="todo">talk about dynamic type changing</p>

<h2 id="h2themodel">The Model</h2>
<p>
In essence a model is the totality of entities and their inter-relationships from a target system. A MooseModel is a special Group.
</p>
<p>
The simplest model is the empty one. You can get it by simply instantiating a MooseModel:
</p>
<figure><pre><code> MooseModel new.</code></pre><figcaption></figcaption></figure>

<p>
A model is also an entity, and thus, it can be stored in another model. By default, Moose offers a special root model object that is a singleton and that can be accessed via:
</p>
<figure><pre><code> MooseModel root.</code></pre><figcaption></figcaption></figure>

<p>
The root model is special because by convention it is used to store all other models. It acts as a repository, and its content are displayed in the MoosePanel user interface.
</p>
<p>
To add your model to the root model, you can simply do:
</p>
<figure><pre><code> | myModel |
 myModel := MooseModel new.
 MooseModel root add: myModel.</code></pre><figcaption></figcaption></figure>

<p>
Once an entity is placed in a model, it automatically stores the model in an instance variable accessible via <code>mooseModel</code>. Thus, when a query requires information that is outside of the scope of the entity under study, you can obtain the information from the model.
</p>
<h1 id="h1thefamixfamilyofmeta-models">The FAMIX family of meta-models</h1>

<p>
FAMIX is a family of meta-models for representing models related to various facets of software systems. These meta-models are typically geared towards enabling analysis and they provide a rich API that can be used for querying and navigation.
</p>
<p>
The meta-models are implemented in Pharo, and because Pharo can be used as scripting language, the APIs defined by the meta-models also provide a query language.
</p>

<h2 id="h2thecorelanguage-independentmeta-model">The core language-independent meta-model</h2>
<p>
The Core of FAMIX consists of a language independent meta-model that can represent in a uniform way multiple object-oriented and procedural languages.
</p>
<p>
The figure below offers a an overview of the class hierarchy, including some of the most used extensions. The hierarchy is to be read from left to right, the entities to the right being specializations of those to the left.
</p>
<p>

<figure>
	<img src="figures/famix-hierarchy.png"/>
	<figcaption>Famix hierarch</figcaption>
</figure>
</p>
<p>
The diagram shows the hierarchy, but it does not show the attributes or relationships. To give you an idea of the amount of relations provided by FAMIX, take a look at the figure below (every light gray link represents a relationship between two entities):
</p>
<p>

<figure>
	<img src="figures/famix-hierarchy-relationships.png"/>
	<figcaption>Famix hierarchy</figcaption>
</figure>
</p>
<p>
It can be daunting to try to understand FAMIX all at once. That is why in this chapter we take another route, and provide an overview of the most important parts. What does most important mean? These would be the parts that you are most likely to need in practice. That is not to say that the other parts are useless, but a significant amount of tasks can be accomplished with knowing only a subset of FAMIX.
</p>

<h3 id="h3anincorrect,butusefuloverview">An incorrect, but useful overview</h3>
<p>
In most cases, you get enough information if you master the core types entities that model an object-oriented system. These are Namespace, Package, Class, Method, Attribute, and the relationships between them, namely Inheritance, Access and Invocation. The figure below provides an overview of these classes.
</p>
<p>

<figure>
	<img src="figures/famix-overview.png"/>
	<figcaption>A useful Famix overview</figcaption>
</figure>
</p>
<p>
This is an incorrect overview from two points of view:
</p><ol><li>It does not show all entities. For example, a Method has also a Parameters and LocalVariables.</li>
<li>At places, it shows direct relationships when in reality they happen through inheritance. For example, the Access points to an Attribute, while in reality it points to a superclass (StructuralEntity).</li>
</ol>

<p>
However, while incorrect, this picture is also useful because for most practical purposes it is all you need. Let us go through it step by step.
</p>
<p>
There isn't much to say about most of the picture. Most of it goes along the lines of mirroring  code concepts. For example, classes have methods, and methods belong to classes. More worthy of being noticed is the use of explicit entities to model relationships. Thus, we have:
</p><ul>
<li>Inheritance models as its names says object-oriented inheritance between two classes and: the subclass, and the superclass.</li>
<li>Access denotes a connection between a behavioral entity (often a Method in object-oriented systems) and an structural entity (often an Attribute).</li>
<li>Invocation is a connection between one source and one or more target behavioral entities (often Methods). There can be more than one target behavioral entity because in dynamic languages we cannot identify statically with 100% accuracy the target of an invocation. See <a href=""></a> for more details.</li>
</ul>

<p>
Another point that often generates confusion is the presence of both Namespace and Package in the meta-model. These are similar entities, but they model different things. Namespaces have a semantic meaning in the language so they influence the unique name of the entity, while a Package are physical entities for packaging:
</p><ul>
<li>In Smalltalk the two are explicitly different.</li>
<li>In C++ we have explicit Namespaces, but not so explicit Packages. A C++ namespace has no other responsibility beside providing a lexical scope for the contained classes and funcions.</li>
<li>In Java, we have both Namespace (what you define in your Java source), and Package (the folder structure), but they happen to overlap in naming (although one is with . and the other one is with /). As a consequence, people tend to see them as packages only. It is for this reason, that Java extractors map Java packages to FAMIX Namespaces. Some can also mirror the same information in terms of FAMIX Packages.</li>
</ul>

<p>
Please note the missing arrows on the associations. This is not a mistake. In FAMIX, all associations are bidirectional. Let us take an example. Given the model from our running example, we have:
</p>
<figure><pre><code>aClass := model allClasses entityNamed: #'org::argouml::ui::Critic'.
aClass methods first parentType == aClass
&quot;--&gt; true&quot;</code></pre><figcaption></figcaption></figure>

<p>
In other words, we can navigate from a class to its methods and back using only unary methods. Furthermore, these relationships are cached in the entities, and thus the traversal works fast.
</p>
<p>
The reason for this mechanism is that we want to offer the possibility of traversing the model from any point to any point. This is particularly useful when we use the API as a query language.
</p>
<p class="todo">naming convention for attributes</p>

<h3 id="h3types">Types</h3>
<p>
Types are central to object-oriented systems. In this section, we take a closer look at the type hierarchy and related classes.
</p>
<p>
The root of the hierarchy is simply Type. This is a generic class representing a type in an object-oriented language. It can have many Methods and Attributes.
</p>
<p>
A type can also take part in inheritance relationships. This happens by means of Inheritance entities that connect pairs of types. Multiple inheritance is modeled by simply having multiple inheritance objects connecting the same subclass with multiple superclasses.
</p>
<p>
Type has several specializations for specific kinds of types. The most prominent is provided by Class. This models a typical class in Smalltalk, Java or C++, but it also models a Java interface (by means of the isInterface boolean property).
</p>
<p>
A PrimitiveType is just that: a primitive type. For example, int or char will be modeled using PrimitiveType entities.
</p>
<p>
ParameterizedType and ParameterizableClass model Java generics or C++ templates. In particular, a ParameterizableClass represents the generic definition, while the ParameterizedType represents the actual usage of the generic in a specific context.
</p>
<p>
Let me provide an example based on the following Java snippet:
</p>
<figure><pre><code>public class ClassA&lt;B,C&gt; {...}
...
public ClassA&lt;ActualTypeA,ActualTypeB&gt; anAttribute;</code></pre><figcaption></figcaption></figure>

<p>
In this case, <code>ClassA</code> will be represented by a ParameterizableClass, and the declared type of anAttribute will be an actual ParameterizedType linking to <code>ClassA</code>. Furthermore, <code>B</code> and <code>C</code> will be ParameterTypes, and the corresponding slots from the ParameterizedType will point to the actual types <code>ActualTypeA</code> and <code>ActualTypeB</code>.
</p>
<p>

<figure>
	<img src="figures/famix-types.png"/>
	<figcaption>Types</figcaption>
</figure>
</p>

<h3 id="h3theinvocation">The invocation</h3>
<p>
The Invocation entity models a static invocation between two behavioral entities. Typical behavioral entities are Method and Function, the difference between them being that a Method belongs to a Class, while a Function belongs directly to a Namespace.
</p>
<p>
This entity is one of the most complex in FAMIX, mostly due to it being able to accommodate both statically and dynamically typed languages.
</p>
<p>

<figure>
	<img src="figures/famix-invocation.png"/>
	<figcaption>Invocation</figcaption>
</figure>
</p>

<h3 id="h3theannotations">The annotations</h3>
<p>
Most programming languages have some means to add information to source code that has no direct impact on the execution.
</p>
<p>
Let us take two examples: 
</p>
<figure><pre><code>smalltalkMethodAnnotated
  &lt;primitive: 'primAnyBitFromTo' module:'LargeIntegers'&gt;</code></pre><figcaption></figcaption></figure>

<figure><pre><code>@Test(timeout = 500)
public void javaMethodAnnotated()</code></pre><figcaption></figcaption></figure>

<p class="todo">more on the examples: what is the type, what is the instance, and how they relate to the entity</p>
<p>

<figure>
	<img src="figures/famix-annotations.png"/>
	<figcaption>Annotations</figcaption>
</figure>
</p>

<h3 id="h3famixgenericqueryapi">Famix generic query API</h3>

<p class="todo">examples, composability, main concepts</p>

<h2 id="h2meta-modelextensions">Meta-model extensions</h2>
<p class="todo">navigation, actions</p>
<p class="todo">focus on unary methods</p>

<h2 id="h2themetabrowser">The Meta Browser</h2>
<p>
FAMIX is a family of meta-models and it is meant to be extended. To browse the landscape of the FAMIX implementation at any point in time, we have a dedicated browser that offers a logical view of the meta-descriptions.
</p>
<p>
The Meta Browser can be can be spawned from the Moose menu or by executing:
</p>
<figure><pre><code> MooseModel browseMeta</code></pre><figcaption></figcaption></figure>

<p>
The browser shows the hierarchy of classes to the top-left. Selecting an class shows both the references to other classes and the primitive properties. At the bottom, a map of the overall class hierarchies is provided as a Mondrian visualization. The current selection is shown on the map in red. Furthermore, the comment of the current selection is shown to the right.
</p>
<p>
The picture below shows the browser focused on the <code>SourcedEntity</code> and on the <code>sourceAnchor</code> property.
</p>
<p>

<figure>
	<img src="figures/meta-browser.png"/>
	<figcaption>Meta browser</figcaption>
</figure>
</p>
<h1 id="h1paintingobjectswithroassal">Painting objects with Roassal</h1>

<p>
Digital data has no physical shape. While this allows us to manipulate easily great amounts of data, it poses a problem when it comes to understanding this data and assessing its state. The lack of physical shape renders useless our built-in skill of perceiving the world around us through visual stimuli.
</p>
<p>
Visualization aims to solve this problem by offering a visual skin to data. “A picture tells a thousand words” goes the old adage. And so it does, but only if the picture is the right one.
</p>
<p>
What makes a picture appropriate? Well, it has to focus on one or more relevant questions, and it has to take the particularities of data into account.
</p>
<p>
There are many tools out there providing nice and useful visualizations for interesting questions. However, many of them offer only limited customization possibilities, and this makes them less useful in particular circumstances.
</p>
<p>
To address this issue, the Moose platform ships with Roassal, an engine for scripting interactive visualizations.
</p>
<h2 id="h2roassalinaction">Roassal in action</h2>

<p>
The <code>ArgoUML-0-34</code> case study contains several modules that can be distinguished by the appearance of a <code>build.xml</code> file in the module root folder.
</p>
<p>
Where are these modules located throughout the overall folder structure? To find this out, we visualize the tree of folders.
</p>
<figure><pre><code>interestingDirectories := self withDeepCollect: [: each | 
	(each files anySatisfy: [ :f | f basename asLowercase = 'build.xml' ])
		ifTrue: [ #() ]
		ifFalse: [ each directories ] ].
view := RTMondrian new.
view shape circle
	size: 5;
	if: [ :each | each files anySatisfy: [ :f | f basename asLowercase = 'build.xml' ] ] color: Color red.
view nodes: interestingDirectories.
view edges connectFrom: #parent.
view layout tree.</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/inspector-roassal-argo-modules-tree.png"/>
	<figcaption>Sub projects as tree</figcaption>
</figure>
</p>
<p>
Visualize the location of project directories using a circular tree map:
</p>
<figure><pre><code>b := RTCircularTreeMapBuilder new.
b shape if: [ :each | each files anySatisfy: [ :f | f basename asLowercase = 'build.xml' ] ] color: Color red.
b leafWeight: 1.
b explore: self nesting: #directories leaves: #directories.
b</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/inspector-roassal-argo-modules-treemap.png"/>
	<figcaption>Sub projects as tree map</figcaption>
</figure>
</p>

<p>
Visualize the location of project directories using a sunburst:
</p>
<figure><pre><code>b := RTSunburstBuilder new.
b shape color: [ :each | (each files anySatisfy: [ :f | f basename asLowercase = 'build.xml' ]) ifTrue: [ Color red ] ifFalse: [ Color lightGray ] ].
b leafWeight: 1.
b angularSpacing: 5.
b explore: self nesting: #directories leaves: #directories.
b</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/inspector-roassal-argo-modules-sunburst.png"/>
	<figcaption>Sub projects as sunbirst</figcaption>
</figure>
</p>


<h2 id="h2visualizingdependenciesbetweentarget">Visualizing dependencies between target </h2>

<figure><pre><code>tags := (XMLDOMParser parse: self) // 'target'.
view := RTMondrian new.
view nodes: tags.
view edges connectFromAll:  [:aTag | |depends|
	depends:=(aTag @ 'depends') stringValue splitOn: ', '.
	tags select: [ :each | 
		depends includes: (each @ 'name') stringValue] ].
view layout dominanceTree.
view.</code></pre><figcaption></figcaption></figure>

<a id="cha:Glamour"></a>
<h1 id="h1buildingbrowserswithglamour">Building browsers with Glamour</h1>

<p>
Large models hold many details. Tons of details. The sheer size is precisely what makes it can be hard for us to grasp systems in one shot. Browsers offer an alternative. A browser is a specific user interface that allows us to look at the space provided by the model, to navigate from one part of this space to another, and to act upon it.
</p>
<p>
For example, both the Inspector and the Moose Finder are browsers. They have a workflow that works well for many situations, but this workflow is still hardcoded and at times it is not flexible enough to accommodate custom needs. An alternative way is to use a custom browser. For example, when it comes to manipulating code, we could write code in the Inspector, but we typically prefer not to. We use a dedicated code browser instead.
</p>
<p>
Dedicated browsers are desirable, but they are typically expensive to build. As a result we have no dedicated way to browse the large majority of models around us. This situation needs rectification, and Glamour presents the solution in the form of an engine for building dedicated browsers. In fact, the Inspector and the Moose Finder are written in Glamour.
</p>
<p>
This chapter describes the details of Glamour. It starts with a short tutorial and then it gradually introduces the architecture and the most important concepts.
</p>

<h2 id="h2aglimpseofglamour">A glimpse of Glamour</h2>

<p>
How exactly does Glamour help us build dedicated browsers? The rest of this section tries to answer this question via a hands-on example.
</p>
<p>
Previously, we saw that the  <code>ArgoUML-0-34</code> system is comprised of several submodules identified by the presence of a <code>build.xml</code> file in the folder. To get a better handling of these build files, we construct a dedicated browser for them. For example, we can show all modules to the right, and the details related to the build file of each module to the right. 
</p>
<p>

<figure>
	<img src="figures/glamour-action-1.png"/>
	<figcaption>Simple build browser</figcaption>
</figure>
</p>
<p>
From a conceptual point of view, this browser is composed out of two panes that are connected such that when we select something in the first one, the second pane shows related information.
</p>
<p>
Let's construct this step by step. Open a Playground and type: 
</p>
<figure><pre><code>GLMCompositePresentation new tabulator 
	with: [ :t |
		t column: #index; column: #details.
		t transmit to: #index; andShow: [ :composite | 
			composite list 
				title: 'Projects';
				format: [:each | each parent basename]] ];
	openOn: (MooseModel root allModels anyOne rootFolder asFileReference allFiles select: [ :each | each basename = 'build.xml' ]).</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/glamour-action-2.png"/>
	<figcaption>Browser with one list</figcaption>
</figure>
</p>
<p>
We build a browser with two panes: <code>#index</code> and <code>#details</code>. When opening the browser, we transmit to the <code>#index</code> pane the input and we show in the pane a list presentation that is entitled <code>'Projects'</code>. The list also formats its elements by showing only the basename of the parent directory. We open the overall browser on the list of all build files. One thing to notice here is that we focus primarily on how data flows, and only afterwards on how it is presented.
</p>
<p>
Still, nothing happens when selecting an item from our list. That's because we did not connect the two panes. Let's connect them.
</p>
<figure><pre><code>GLMCompositePresentation new tabulator 
	with: [ :t |
		t title: 'Build browser'.
		t column: #index; column: #details.
		t transmit to: #index; andShow: [ :composite | 
			composite list 
				title: 'Projects';
				format: [:each | each parent basename] ].
		t transmit from: #index; to: #details; andShow: [ :composite |
			composite text
				title: 'XML';
				display: [ :file | file contents ] ] ];
	openOn: (MooseModel root allModels anyOne rootFolder asFileReference allFiles select: [ :each | each basename = 'build.xml' ] )			</code></pre><figcaption></figcaption></figure>

<p>
The second transmission connects the selection from <code>#index</code> with the input from <code>#details</code> and it shows a text that displays the contents of the file.
</p>
<p>

<figure>
	<img src="figures/glamour-action-3.png"/>
	<figcaption>Browser with two connected panes</figcaption>
</figure>
</p>
<p>
We can now also add extra presentations with more details in the second pane. 
</p>
<figure><pre><code>GLMCompositePresentation new tabulator with: [ :t |
	t column: #index; column: #details.
	t transmit to: #index; andShow: [ :composite | 
		composite list
			title: 'Projects';
			format: [:each | each parent basename] ].
	t transmit from: #index; to: #details; andShow: [ :composite |
		composite text
			title: 'XML';
			display: [ :file | file contents ].
		composite list 
			title: 'Targets';
			display: [ :file | (XMLDOMParser parse: file contents) // 'target' ];
			format: [ :xmlElement | xmlElement attributeAt: 'name' ].
		composite roassal2
			title: 'Dependencies';
			initializeView: [ RTMondrian new ];
			painting: [ :view :file | 
				| tags |
				tags := (XMLDOMParser parse: file) // 'target'.
				view shape label text: [:each | (each @ 'name') stringValue].
				view nodes: tags.
				view shape line color: (Color gray alpha: 0.5).
				view edges connectFromAll:  [:aTag | |depends|
					depends:=(aTag @ 'depends') stringValue splitOn: ', '.
					tags select: [ :each | 
						depends includes: (each @ 'name') stringValue] ].
				view layout horizontalDominanceTree.
				] ].
	];
	openOn: (MooseModel root allModels anyOne rootFolder asFileReference
 allFiles select: [ :each | each basename = 'build.xml' ]).</code></pre><figcaption></figcaption></figure>

<p>
In this case, one of the presentation is another list showing only the <code>&lt;target&gt;</code> tags from the build files, and another presentation is a Roassal visualization showing the dependencies between the <code>&lt;target&gt;</code> tags.
</p>
<p>

<figure>
	<img src="figures/glamour-action-4.png"/>
	<figcaption>Browser with two connected panes and multiple presentations</figcaption>
</figure>
</p>
<p>
Not bad so far. Still, why should we see the XML details only for the overall file? Why not see the XML of the tags as well?
</p>
<p>
Let's transform a bit our browser:
</p>
<figure><pre><code>GLMCompositePresentation new tabulator with: [ :t |
	t title: 'Build browser'.
	t 
		row: [:r | r column: #index; column: #details];
		row: #source.
	t transmit to: #index; andShow: [ :composite | 
		composite list
			title: 'Projects';
			format: [:each | each parent basename] ].
	t transmit from: #index; to: #details; andShow: [ :composite |
		composite list 
			title: 'Targets';
			display: [ :file | (XMLDOMParser parse: file contents) // 'target' ];
			format: [ :xmlElement | xmlElement attributeAt: 'name' ].
		composite roassal2
			title: 'Dependencies';
			initializeView: [ RTMondrian new ];
			painting: [ :view :file | 
				| tags |
				tags := (XMLDOMParser parse: file) // 'target'.
				view shape label text: [:each | (each @ 'name') stringValue].
				view nodes: tags.
				view shape line color: (Color gray alpha: 0.5).
				view edges connectFromAll:  [:aTag | |depends|
					depends:=(aTag @ 'depends') stringValue splitOn: ', '.
					tags select: [ :each | 
						depends includes: (each @ 'name') stringValue] ].
				view layout horizontalDominanceTree.
				] ].
		t transmit from: #index; to: #source; andShow: [ :composite |
			composite text
				title: 'XML';
				display: [ :file | file contents ] ].
		t transmit from: #details; to: #source; andShow: [ :composite |
			composite text
				title: 'XML';
				display: [ :xmlElement | xmlElement gtDisplayString ] ].
			
	];
	openOn: (MooseModel root allModels anyOne rootFolder asFileReference
 allFiles select: [ :each | each basename = 'build.xml' ])</code></pre><figcaption></figcaption></figure>

<p>
Now, we created an extra pane named <code>#source</code> and we transmit to it both from the <code>#index</code> pane and from the <code>#details</code> pane.
</p>
<p>

<figure>
	<img src="figures/glamour-action-5.png"/>
	<figcaption>Browser with separate XML preview</figcaption>
</figure>
</p>
<p>
That is about it.
</p>
<p class="note">In short, in Glamour get five main concepts: a <em>browser (1)</em> is made of <em>panes (2)</em> which represent spatial locations on which various <em>objects (3)</em> are <em>presented (4)</em>. Furthermore, the result of acting on the graphical <em>presentation (4)</em> is <em>transmitted (5)</em> to other panes.</p>
<h2 id="h2glamourarchitecture">Glamour architecture</h2>
<p>
The architecture of Glamour revolves around a handful of concepts. The picture below shows a UML diagram with an overview of these.
</p>
<p>
<img src="figures/glamour-architecture.png"/>
</p>
<p>
The central concept is the Browser which encapsulates the entire interaction and presentation logic of a browser.
</p>
<p>
A Browser is composed of Panes. A pane defines physical locations in a Browser. A Pane manages its state through named Ports which can hold any objects as value. 
</p>
<p>
The navigation flow is specified via Transmissions. A Transmission connects several origin ports with a destination port, and its job is to handle the propagation of values between these. In essence, when the value of an origin port changes the Browser analyzes its Transmissions and those that originate in that particular port are subject to being triggered.
</p>
<p>
Essentially, the constructs of Panes, Ports and Transmissions correspond to a components and connectors architecture in which the components are connected in a directed graph.
</p>
<p>
Panes only define the location in the Browser, but the way they should be rendered is handled by Presentations. A Presentation interprets the state of the Pane and maps it to visual characteristics through a strategy pattern. Thus, we can have multiple types of Presentations: TextPresentation, ListPresentation and so on.
</p>
<p>
Furthermore, Presentations can also be composed in a CompositePresentation. In fact, a Pane is always represented by such a composite.
</p>

<h2 id="h2sketchingbrowsers">Sketching browsers</h2>
<p>
To ease the conception of browsers we can use a dedicated notation to capture the critical aspects: Pane, Port, Transmission and Presentation (and Browsers). A sketch of a browser and the corresponding legend can be seen below.
</p>
<p>
<img src="figures/glamour-notation.png"/>
</p>
<p>
The flow of a browser can at times become difficult to follow. This notation is meant to ease in that situation.
</p>
<p class="note">Use this even for simple browsers. Before coding a browser, start by sketching it on a paper. This will help you crystalize the way the information flows through your browser.</p>

<h2 id="h2handlingtransmissions">Handling transmissions</h2>
<p>
The fundamental idea behind Glamour starts from the observation that the navigation flow should be orthogonal to the way of presentation. In Glamour, this navigation flow is captured through Panes, Ports and Transmissions: the Panes represent the building blocks, the Ports provide the hooks, and the Transmissions form the fiber of the browser by connecting the ports.
</p>
<p>
The following UML class diagram shows the most important classes and methods related to understanding Transmissions. A Transmission connects a destination port with one or multiple origin Ports. When triggered, the main job of the Transmission is to take the values from the origin ports and combines them to populate the destination port. Further behavior can be appended to this basic one through a transmission strategy.
</p>
<p>
An origin port can be either active (specified using <code>from:port:</code>) or passive (specified using <code>passivelyFrom:port:</code>). Only the active origin ports can trigger a transmission. This information is captured by the PortReference.
</p>
<p class="todo">explain what is the use of a passive port</p>
<p>
As mentioned, a Transmission can have several origin ports. This is achieved by sending multiple messages like <code>from:port:</code>. As a result of triggering a transmission with multiple origins, the target port contains a special ordered collection populated with the values from the origins. These values are then accessible when defining the properties of the desired presentations.
</p>
<p>
In most cases transmissions originate in a <code>#selection</code> port and have as destination an <code>#entity</code> port. For convenience, Glamour provides some shorter messages that make use of this observation:
</p><ul>
<li>For specifying a transmission origin that points to a <code>#selection</code> port of a pane, you simply use <code>from:</code>.</li>
<li>Similarly, for specifying a transmission destination that points to an <code>#entity</code> port of a pane, you can use <code>to:</code>.</li>
</ul>

<p>
The triggering of a Transmission can be controlled by a condition specification. This condition is set via a <code>when:</code> message that takes as a parameter a block returning a boolean depending on the values of the origin ports.
</p>
<p>
Transmissions have deep control over the values passed around via transformation specifications. There are two hooks for such transformations.
</p>
<p>
The main transformation is offered by the Transmission itself and it comes in the form of a block that takes as parameters the values from the origin ports and returns the desired value to be set in the destination port. This can be specified via a <code>transformed:</code> message sent to the transmission.
</p>
<p>
The second hook is provided by the PortReference. Using this transformation, we can transform each individual port before it gets in the Transmission transformation. We can specify such a transformation for each individual origin port using <code>from:transformed:</code> or <code>passivelyFrom:transformed:</code>. 
</p>
<p>
Besides setting the value to a destination port, a Transmission can have further behavior via a TransmissionStrategy. This is useful when we want the transmission to also impact the presentations from the pane of the target destination. Besides the NoStrategy default strategy, there are two more semantics presently implemented:
</p><ol><li>ReplacePresentationsStrategy replaces the presentations from the pane of the destination port with those specified by the strategy. This one is set via the <code>andShow:</code> message.</li>
<li>PresentIfNoneStrategy sets presentations only if none exits in the pane of the destination port. This one is set via the <code>andShowIfNone:</code> message.</li>
</ol>

<p>
Both the <code>andShow:</code> and the <code>andShowIfNone:</code> messages expect a block with one parameter consisting of a composite presentation that will be used by the transmission.
</p>
<p>
<img src="figures/transmission-semantics.png"/>
</p>
<p>
The following pieces of code offer some examples of the most common cases of transmissions:
</p>
<figure><pre><code>&quot;transmission with multiple origins that replaces presentations&quot;
browser transmit 
  from: #paneOne;
  from: #paneTwo port: #portB;
  to: #paneThree;
  andShow: [ :a | 
    &quot;specification of presentations based on two variables&quot; ].</code></pre><figcaption></figcaption></figure>

<figure><pre><code>&quot;transmission that installs a presentation only if none exists in the target panel&quot;
browser transmit 
  from: #paneOne;
  to: #paneTwo;
  andShowIfNone: [ :a | 
    &quot;specification of presentations&quot; ].</code></pre><figcaption></figcaption></figure>


<figure><pre><code>&quot;transmission with multiple origins and with transformations&quot;
browser transmit 
  from: #paneOne transformed: [ :paneOneSelectionValue | 
    &quot;computation of the transformed value based on one variable&quot; ];
  from: #paneTwo port: #portB;
  to: #paneThree;
  transformed: [ :transformedPaneOneSelectionValue :portBValue |
    &quot;computation of the destination value based on two variables&quot; ]</code></pre><figcaption></figcaption></figure>

<figure><pre><code>&quot;transmission with one origin bound to the pane surrounding the browser
 (i.e., the outside port)&quot;
browser transmit 
  fromOutsidePort: #outsidePort;
  to: #paneThree port: #portC.</code></pre><figcaption></figcaption></figure>

<figure><pre><code>&quot;transmission with the origin bound to the #entity port of the pane of the browser&quot;
browser transmit 
  to: #paneThree port: #portC.</code></pre><figcaption></figcaption></figure>


<h2 id="h2specifyingpresentations">Specifying presentations</h2>
<p>
A Presentation defines the way a Pane is to be displayed and how the user interaction should change its state. It does that by interpreting the values from the Ports and by specifying how these Ports should change.
</p>
<p>
Presentations can be parameterized in several ways using blocks. The basic parameters are:
</p><ul>
<li>Every presentation has a title set via <code>title:</code>.</li>
<li>A presentation can transform the input into a model better suited for it. This is accomplished via the <code>display:</code> message.</li>
<li>The visibility of each presentation can be controlled via a condition block that is set by sending a <code>when:</code> message. </li>
<li>By default, there is an implicit condition saying that all input objects must be not nil for the presentation to appear. If we still want to allow the presentation to appear even if the the input objects are nil we can use <code>allowNil</code>.</li>
</ul>

<p>
All these specifications take as input blocks that accept a variable number of parameters depending on the number of objects present in the <code>#entity</code> port. 
</p>
<p>
In our example, we only used transmissions with one origin, and thus the display blocks took one parameter as input. For example, the code below describes how on the <code>#details</code> pane we should show a TextPresentation that should <code>display:</code> the result of a block that takes as parameter the <code>#selection</code> from the <code>#methods</code> pane, and this in turn happens to be a method entity which understands <code>sourceText</code>.
</p>
<figure><pre><code>browser transmit from: #methods; to: #details; andShow: [ :composite |
  composite text
    display: [ :method | method sourceText ] ].</code></pre><figcaption></figcaption></figure>

<p>
If on the other hand, we might want to be able to show the source code for both a class and a 
method, we could write:
</p>
<figure><pre><code>| browser |
&quot; ... &quot;
browser transmit
  from: #classes;
  from: #methods; 
  to: #details; andShow: [ :composite |
    composite text
      title: [ :class | class name, ' source'];
      display: [ :class | class sourceText ];
      allowNil.
    composite text
      title: [ :class :method | method name, ' source'];
      display: [ :class :method | method sourceText ] ].</code></pre><figcaption></figcaption></figure>

<p>
Because now we have two origins, there will be two objects in the #entity port corresponding to the selected class and to the selected method. Thus, the <code>display:</code> block of the presentations  accepts two parameters. However, when we only need the first one we can leave the second one out, as is the case for displaying the class source text. Furthermore, because we want to display the class source even when no method is selected, we want to allow the presentation to appear even when one of the ports is nil.
</p>
<p>
Glamour offers multiple types of presentations, and the figure below shows an overview. Some of these correspond to basic widgets that can be found in user interface frameworks, while others are more sophisticated and tailored for the needs of browsing. The following section describe each of them.
</p>
<p>
<img src="figures/glamour-presentations-details.png"/>
</p>
<p class="todo">clarify how presentations consume and populate ports</p>

<h3 id="h3compositepresentation">Composite presentation</h3>
<p>
Every pane has a reference to a Composite Presentation. Thus, whenever we specify a transmission, we get access to such a composite presentation.
</p>
<figure><pre><code>| browser | 
&quot; ... &quot;
browser transmit from: #paneOne; to: #paneTwo; andShow: [ :composite |
  &quot;composite is a CompositePresentation that will be installed on the destination pane&quot; ].</code></pre><figcaption></figcaption></figure>

<p>
The job of a composite is to regulate the display of the contained presentations. To this end, it allows us to specify a so called arrangement.
</p>
<p>
There are three different kinds of arrangements currently offered:
</p><ul>
<li>TabbedArrangement arranges multiple presentations under a tab widget. This is the default arrangement.</li>
<li>StackedVerticallyArrangement lays out the presentations one below the other in group boxes.</li>
<li>AccordionArrangement offers the possibility to collapse the presentations using an accordion widget.</li>
</ul>

<p>
Specifying the arrangement is straightforward. For example:
</p>
<figure><pre><code>| browser | 
&quot; ... &quot;
browser transmit from: #paneOne; to: #paneTwo; andShow: [ :composite |
  composite stackedVerticallyArrangement.
  &quot;...&quot; ].</code></pre><figcaption></figcaption></figure>


<h3 id="h3listingpresentations">Listing presentations</h3>
<p>
There are three ListingPresentations available: List, Tree and Table. Each of these expects the result of evaluating the transformation on a given input entity (by using <code>display:</code>) to be a list.
</p>
<p>
In the case of the ListPresentation, this list is then mapped on the elements in the list widget to be displayed. For example, to display the namespaces from a MooseModel in a list you can use:
</p>
<figure><pre><code>browser transmit to: #namespaces; andShow: [ :composite |
   composite list
      display: [ :model | model allNamespaces ] ].</code></pre><figcaption></figcaption></figure>

<p>
A TablePresentation goes along the same line, only it adds the possibility to also add columns using <code>column:evaluated:</code>. For example, if we want to display the number of classes in each namespace, we can do it like:
</p>
<figure><pre><code>browser transmit to: #namespaces; andShow: [ :composite |
   composite table
      display: [ :model | model allNamespaces ];
      column: 'Namespaces' evaluated: [ :each | each mooseName ];
      column: 'NOCls' evaluated: [ :each | each classes size asString ] ].</code></pre><figcaption></figcaption></figure>

<p>
A TreePresentation is slightly different. The list to be displayed will appear as root elements in the tree. Thus, if we want to show the tree of all namespaces, in the display block we have to select only the root ones and then specify the children (using <code>children:</code>) for each of the namespaces:
</p>
<figure><pre><code>browser transmit to: #namespaces; andShow: [ :composite |
   composite tree
      display: [ :model | model allNamespaces select: [ :each | each isRoot ] ];
      children: [ :namespace | namespace childScopes ] ].</code></pre><figcaption></figcaption></figure>

<p>
The ListingPresentations also offer further options. First, we can specify how to deal with the selection. In this area we can say if we want the selection to <code>beSingle</code> (the default option) or to <code>beMultiple</code>. When multiple selection is wanted, the result of populating the <code>#selection</code> port is a collection. Yet another selection related issue is to <code>allowDeselection</code> of the current selection. If the listing is set to allow deselection, when deselecting the <code>#selection</code> port is set to <code>nil</code>.
</p>
<p>
Second, we have the possibility to ask for an input box that acts as a filter (using <code>filterOn:</code>) or as a search box (using <code>searchOn:</code>). Both accept as parameter a block that takes each element of the list as input and returns a true or false. The effect of the filter box is to trim the visible items based on the selection. The effect of the search box is to select the desired item and to populate the <code>#selection</code> port. For example, in the Moose Finder (see <a href=""></a>) the group view offers a search box with which we can select the wanted elements in the group. Once selected, the <code>#selection</code> port is populated appropriately.
</p>
<p>
Third, it is sometimes impractical to show an entire list, especially when we deal with very large lists. In such situations it is better to show only a limited amount of items by using <code>showOnly:</code>. For example, this can be seen in the Moose Finder where we typically do not show more than 50 elements by default.
</p>
<p>
Finally, we also have the possibility to add tags to the items of a list by using <code>tags:</code>.
</p>
<p class="todo">icon</p>
<p class="todo">input and output ports: #selection, #strongSelection, #selectedPath</p>

<h3 id="h3textpresentation">Text presentation</h3>
<p>
A TextPresentation offers the possibility to display a text in an editor. For example, suppose we have a class at hand, we can display the source code in the following way:
</p>
<figure><pre><code>browser transmit to: #source; andShow: [ :composite |
   composite text
      display: [ :class | class sourceText ] ].</code></pre><figcaption></figcaption></figure>

<p>
The presentation offers control over the setting and retrieving the currently selected text. The selected text is provided via the port named <code>#selectedText</code>. It is not provided through the <s><code>#selection</code></s> port, because in most cases, it is not text that we want as an abstraction to pass forward to other ports. Furthermore, we can also set the currently selected text through the <code>#selectionInterval</code> port.
</p>

<h3 id="h3labelpresentation">Label presentation</h3>
<p>
A Label Presentation displays a non-interactive label as a piece of text that should fit on one line. To specify, simply use a piece of code along the lines of:
</p>
<figure><pre><code>  composite label display: [ :entity | 'A label example' ].</code></pre><figcaption></figcaption></figure>

<p>
Labels typically go well with a fix-size pane. For example:
</p>
<figure><pre><code>| browser |
browser := GLMTabulator new.
browser row: #variable; row: #fix size: 20.
browser transmit to: #fix; andShow: [ :composite | composite label display: 'Fix size'].
browser showOn: #variable; using: [browser text display: 'Variable size'].
browser openOn: 1 </code></pre><figcaption></figcaption></figure>


<h3 id="h3smalltalkcodepresentation">Smalltalk code presentation</h3>
<p>
The SmalltalkCode presentation is a specialization of the TextPresentation that provides handy features for handling Smalltalk code: syntax highlighting and code completion.
</p>
<p>
There are two modes in which this presentation can be used:
</p><ol><li>by default, the presentation behaves like a Smalltalk Workspace, and it highlights the code as if it were written in the Smalltalk Workspace.</li>
<li>by specifying a <code>smalltalkClass:</code> you can specialize it and make it behave as a method code editor. This property takes as parameters the entity objects and its evaluation is expected to produce a Smalltalk class. As a result the code will be highlighted as if it were a method definition inside the specified class.</li>
</ol>

<p>
When in the Workspace mode, you can also specify variable bindings that can be passed to the overall context. This is achieved by getting the <code>variableBindings:</code> return a collection of associations in which each key is the name of the variable, and each value is the value of the corresponding variable.
</p>
<p>
An example of a simple Smalltalk code can be seen below:
</p><figure><pre><code>| browser |
browser := GLMTabulator new.
browser row: #code span: 2; row: #preview.
browser transmit to: #code; andShow: [ :composite | 
  composite smalltalkCode 
    title: 'Smalltalk Code';
    populate: #acceptedCode
      icon: GLMUIThemeExtraIcons glamorousAccept
      on: $s 
      entitled: 'Accept'
      with: [:text | text text ] ].
browser transmit from: #code port: #acceptedCode; to: #preview; andShow: [ :composite | 
  composite text 
    title: 'Evaluated result';
    display: [:code | [Compiler evaluate: code ] on: Error do: ['Error']] ].
browser openOn: '1+2'</code></pre><figcaption></figcaption></figure>


<h3 id="h3roassalpresentation">Roassal presentation</h3>

<p>
The RoassalPresentation offers the means to integrate a Roassal view inside a browser.
</p>
<p>
The presentation can simply be customized through a <code>painting:</code> block that takes a <code>view</code> or a <code>builder</code> variable as a first parameter and the entity variables as the following parameters. Let's see an example of building a simple browser with two panes showing an overview of all classes to the left and for each selected class displaying a Class Blueprint visualization to the right:
</p>
<figure><pre><code>| browser |
browser := GLMTabulator new.
browser title: 'Blueprint Browser'.
browser column: #complexity; column: #blueprint.
browser transmit to: #complexity; andShow: [:composite | 
	composite roassal2
		title: 'Overview';
		initializeView: [RTCircularTreeMapBuilder new];
		painting: [ :builder :model | 
			builder shape
				borderColor: Color veryLightGray;
				if: [ :each | each isClass and: [ each isStub not ] ] color: [ Color blue lighter ].
			builder
				leafWeight: [:class | class isClass ifTrue: [class outgoingInvocations size ] ifFalse: [ 0 ] ]; 
				from: (model allNamespaces select: [ :each | each isRoot ])
				nesting: [ :each | each childScopes ]
				leaves: [ :each | each classes ] ] ].
browser transmit from: #complexity; to: #blueprint; andShow: [:composite | 
	composite roassal2 
		title: #mooseName;
		painting: [ :view :class | 
			class viewBlueprintOn: view ];
		whenKindOf: FAMIXClass ].
browser openOn: MooseModel root allModels anyOne</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/glamour-roassal-example.png"/>
	<figcaption>Embeddeding Roassal visualization into Glamour</figcaption>
</figure>
</p>
<p>
The example shows two distinct Roassal visualizations embedded in different ways. The first one, uses a dedicated builder, namely <code>RTCircularTreeMapBuilder</code> and specifies the visualization explicitly in a painting block. The second one,  uses the default <code>RTView</code> and  reuses the visualization already defined in  <code>FAMIXType&gt;&gt;viewBlueprintOn:</code>. 
</p>
<p>
The RoassalPresentation populates the <code>#selection</code> port with the object behind the selected element. Furthemore, populating the <code>#selection</code> port from outside leads to selecting the element with the corresponding object behind.
</p>
<h3 id="h3magrittepresentation">Magritte presentation</h3>
<p>
Magritte is a framework for meta-describing data, and one of its applications is the automatic generation of user interfaces for handling data. An extensive description of the concepts of Magritte is provided at: <a href="http://book.seaside.st/book/advanced/magritte">http://book.seaside.st/book/advanced/magritte</a>.
</p>
<p>
All that is required by the Magritte engine is a description for each of the handled entities. Thus, the MagrittePresentation expects the evaluation of the <code>display:</code> block to return an object that can be used for the model behind the <code>description:</code>. Once the description obtained, it is simply passed to Magritte and the engine takes care of the rendering.
</p>
<p>
As an example, let us set our mind to create a small tool to help us review source code. More specifically, we want for each class we inspect in the code browser to have a small form that enables us to write a comment and to mark the class as problematic.
</p>
<p>
We first need the class that will hold the review information. Thus, we create <code>TMBReview</code> class that holds a comment and problematic instance variables:
</p>
<figure><pre><code>Object subclass: #TMBReview
    instanceVariableNames: 'comment problematic'
    classVariableNames: ''
    poolDictionaries: ''
    category: 'TheMooseBook-Examples'</code></pre><figcaption></figcaption></figure>

<figure><pre><code>TMBReview&gt;&gt;comment
  ^ comment</code></pre><figcaption></figcaption></figure>

<figure><pre><code>TMBReview&gt;&gt;comment: aString
  comment := aString</code></pre><figcaption></figcaption></figure>

<figure><pre><code>TMBReview&gt;&gt;problematic
  ^ problematic</code></pre><figcaption></figcaption></figure>

<figure><pre><code>TMBReview&gt;&gt;problematic: aBoolean
  problematic := aBoolean</code></pre><figcaption></figcaption></figure>

<p>
The next step is to make this class Magritte aware:
</p>
<figure><pre><code>TMBReview class&gt;&gt;descriptionComment
  ^ MAStringDescription new
        accessor: #comment;
        label: 'Comment';
        priority: 100;
        yourself</code></pre><figcaption></figcaption></figure>

<figure><pre><code>TMBReview class&gt;&gt;descriptionProblematic
 ^ MABooleanDescription new
        accessor: #problematic;
        label: 'Problematic';
        priority: 200;
        yourself</code></pre><figcaption></figcaption></figure>

<p>
Once we have that, we can just go ahead and build our browser:
</p>
<p class="todo">replace this example with the XML one</p>
<figure><pre><code>| browser |
browser := GLMTabulator new.
browser title: 'Reviewer'.
browser
  row: [ :r | r column: #namespaces; column: #classes; column: #methods ];
  row: [:r  | r column: #details span: 2; column: #review ].
browser transmit to: #namespaces; andShow: [ :composite |
  composite tree
    display: [ :model | model allNamespaces select: [ :each | each isRoot ] ];
    children: [ :namespace | namespace childScopes ];
    format: [ :namespace | namespace stubFormattedName ] ].
browser transmit from: #namespaces; to: #classes; andShow: [ :a |
  a list
    display: [ :namespace | namespace classes ];
    format: [ :class | class stubFormattedName ] ].
browser transmit from: #classes; to: #methods; andShow: [ :a |
  a list
    display: [ :class | class methods ];
    format: [ :method | method stubFormattedName ] ].
browser transmit from: #classes; from: #methods; to: #details; andShow: [ :a |
  a text
    title: [ :class | class name, ' source'];
    display: [ :class | class sourceText ];
    allowNil.
  a text
    title: [ :class :method | method name, ' source'];
    display: [ :class :method | method sourceText ] ].
browser transmit from: #classes; to: #review; andShow: [:a | 
  a magritte 
    title: 'Review';
    display: [ :class |
      | review |
      review := class propertyNamed: #theReview ifAbsentPut: [TMBReview new].
      review ];
    description: #description].</code></pre><figcaption></figcaption></figure>

<p>
For obtaining the review information for each class, we make use of the generic <code>propertyNamed:ifAbsentPut:</code> method present in any Moose entities. Using this, we lazily create a review object if none exists for the current class. We then pass the <code>description</code> of this object to be rendered.
</p>
<p>
Executing the script leads to a browser like in the screenshot below:
</p>
<p>
<img src="figures/glamour-magritte-presentation.png"/>
</p>

<h3 id="h3diffpresentation">Diff presentation</h3>
<p>
A DiffPresentation expects a collection with two pieces of text from the <code>display:</code> block, and it displays the difference between these with a dedicated user interface widget.
</p>
<p>
A simple use case can be encountered when browsing a collection of Duplication entities computed by SmallDude (see <a href=""></a>). Duplication offers information about <code>referenceText</code> and about <code>duplicateText</code>. Thus, we can pass this information to the DiffPresentation and we get back a user interface as in the below example:
</p>
<p class="todo">redo this one</p>
<figure><pre><code>| browser |
browser := GLMTabulator new.
browser title: 'Duplication Browser'.
browser row: #duplications; row: #diff span: 2.
browser showOn: #duplications; using: [browser list].
browser showOn: #diff; from: #duplications; using: [
  browser diff display: [:dup | 
    Array with: dup referenceText with: dup duplicateText ]].
browser openOn: MooseModel root allModels anyOne allDuplications.</code></pre><figcaption></figcaption></figure>

<p>
<img src="figures/glamour-diff-presentation.png"/>
</p>
<p>
The DiffPresentation does not populate any port.
</p>

<h3 id="h3dynamicpresentation">Dynamic presentation</h3>
<p>
The specification of Glamour transmissions and presentations are interpreted at creation time. Thus, by default we do not have the possibility to decide the presentation based on a given entity. The DynamicPresentation rectifies the situation by simply expecting a presentation returned from the block via the <code>display:</code> message.
</p>
<p>
There are two distinct classes of applications for DynamicPresentations: deciding the type or the amount of presentations based on the input entity.
</p>
<p class="todo">describe how the type can also be simulated with when: conditions on regular presentations</p>
<p>
While the type of presentations can be simulated, deciding the number of presentations based on a given entity is not possible without a DynamicPresentation. The following code shows an example of how we could have a method browser that spawns multiple source code viewers when we select multiple methods.
</p>
<figure><pre><code>| browser |
browser := GLMTabulator new.
browser title: 'Multi Methods Viewer'.
browser 
  column: [:c | c row:  #classes; row: #methods];
  column: #source.
browser transmit to: #classes; andShow: [ :a  |
  a list 
    title: 'Classes';
    display: [:model | model allClasses ] ].
browser transmit to: #methods; from: #classes; andShow: [ :a |
  a list 
    title: [ :class | 'Methods from ', class name ];
    beMultiple; 
    display: [ :class | class methods ];
    format: [ :class | class name ] ].
browser transmit to: #source; from: #methods; andShow: [ :a |
  a dynamic with: [ :some :methods | 
    methods do: [ :each |
      some text 
        title: each name asString;
        display: [ each sourceText] ].
    some stackedArrangement ] ].
browser openOn: MooseModel root allModels last.</code></pre><figcaption></figcaption></figure>

<p>
The above browser works on a model. For example, the picture below shows it spawned on the ArgoUML model.
</p>
<p>
<img src="figures/glamour-dynamic-example.png"/>
</p>

<h3 id="h3custompresentations">Custom presentations</h3>
<p>
Presentations are not limited to the default ones shipped with Glamour. Instead, if you desire a specific kind of interaction for your browser, you are encouraged to create a new Presentation.
</p>
<p>
A simple example such a presentation would be one that would allow us to embed any widget from the underlying GUI framework. Glamour already comes with a MorphicPresentation which does nothing else but enable the display of Morphs provided by the Morphic framework of Pharo.
</p>
<p class="todo">change the example to use something else than the inspector</p>
<p>
As an example, suppose we want to reuse the Pharo Inspector by embedding it in a larger browser for inspecting classes from a model. For this we can simply retrieve the morph of the Inspector on each class as in the code below:
</p>
<figure><pre><code>| browser |
browser := GLMTabulator new.
browser title: 'Class Inspector'.
browser column: #classes; column: #inspector span: 2.
browser transmit to: #classes; andShow: [ :a |
  a list
    title: 'Classes' ].
browser transmit to: #inspector; from: #classes; andShow: [ :a |
  a morph 
    title: [ :class | 'Inspector on ', class name]; 
    display: [ :class | 
    PanelMorph new
      layoutPolicy: ProportionalLayout new;
		hResizing: #spaceFill;
		vResizing: #spaceFill;
      addAllMorphs: ( Inspector openAsMorphOn: class ) paneMorphs;
      yourself ] ].
browser openOn: MooseModel root allModels anyOne allModelClasses.</code></pre><figcaption></figcaption></figure>

<p>
Executing the code leads to a user interface that spawns an Inspector for every selected class. Each of these Inspectors offers the same interaction as in the regular incarnation.
</p>
<p>
<img src="figures/glamour-morph-presentation.png"/>
</p>

<p>
While it can be straightforward to build presentations that mirror the user interface widgets, it is desired to build presentations that provide a good abstraction for <em>browsing</em>. Four things are important to keep in mind:
</p>
<ol><li>Presentations should focus primarily on data and on the goal of data interaction;</li>
<li>They should provide an API suitable for scripting;</li>
<li>Because ports are the means to propagate information to the outside of the pane, it is desirable for Presentations to populate at least one port (typically the <code>#selection</code> one). Ideally, it should also populate and react to other ports as well.</li>
<li>Even if the Presentaion does not populate a port, it is advisable to at least allow for Actions to be defined for them. Thus, the user would have the option of using these Actions to populate ports or to change the model.</li>
</ol>


<h2 id="h2scriptingbrowsers">Scripting browsers</h2>
<p>
A Browser dictates the way in which the navigation flow is to be specified. We distinguish between two general types of browsers: 
</p>
<ol><li>Explicit browsers enables us to control the creation of panes and transformations. Currently, there Glamour offers a single implementation of this type of browsers: the Tabulator (see <a href=""></a>)</li>
<li>Implicit browsers come with a built in logic of the navigation flow, and only allow us to customize the presentations. There are two such browsers available: the Finder (see <a href=""></a>) and the Accumulator (see <a href=""></a>) </li>
</ol>

<p>
Perhaps even more interesting is that Browsers can be nested allowing us to reuse complex navigation flows within even more complex ones. <a href=""></a> provides more details.
</p>

<h3 id="h3tabulator">Tabulator</h3>
<p>
As shown in <a href=""></a>, a Tabulator is an explicit browser that allows us to:
</p><ul>
<li>create panes and organize them in a table layout, and</li>
<li>create transmissions between ports of these panes.</li>
</ul>

<p>
The creation and laying out of panes is achieved via a simple scripting API similar to the algorithm behind the computation of a treemap visualization. The following UML diagram lists the relevant methods for this API.
</p>
<p>
<img src="figures/tabulator-layout.png"/>
</p>
<p>
The creation of three panes at the same level can be achieved like:
</p>
<figure><pre><code>browser column: #paneOne.
browser column: #paneTwo.
browser column: #paneThree.</code></pre><figcaption></figcaption></figure>

<p>
or:
</p>
<figure><pre><code>browser row: #paneOne.
browser row: #paneTwo.
browser row: #paneThree.</code></pre><figcaption></figcaption></figure>

<p>
If we want to nest the last two into a parent cell that is placed at the same level as <code>#paneOne</code>, we can achieve it in the following way:
</p>
<figure><pre><code>browser column: #paneOne.
browser column: [ :c | 
  c row: #paneTwo; c row: #paneThree ].</code></pre><figcaption></figcaption></figure>

<p>
respectively: 
</p>
<figure><pre><code>browser row: #paneOne.
browser row: [ :r | 
  r column: #paneTwo; r column: #paneThree ].</code></pre><figcaption></figcaption></figure>

<p>
Thus, the <code>row:</code> and <code>column:</code> messages can be passed a block with one parameter that allows for further nesting. A row will allow us to create nested columns, while in a column we will be able to create nested rows. These parent rows and columns do not have a name because they are only an implementation detail related to the laying out of panes. Only the cells with names lead to the creation of panes that can later be accessed for transmissions.
</p>
<p>
Once panes are created, we can deal with transmissions. A transmission can be created by simply calling <code>transmit</code>. For example, defining a transmission that sets the presentations on #paneThree based on ports from paneOne and portB can be done via a construct like:
</p>
<figure><pre><code>browser transmit 
  from: #paneOne;
  from: #paneTwo-&gt;#portB;
  fromOutside: #outsidePort;
  to: #paneThree;
  andShow: [ :a | 
    &quot;specification of presentations&quot; ].</code></pre><figcaption></figcaption></figure>

<p>
More details about the specification of a transmission are presented in <a href=""></a>. 
</p>

<h3 id="h3finderandpager">Finder and Pager</h3>
<p>
Finder is an implicit browser and it takes its name from the browser used to navigate through the file system of Mac OS X. Pager is a specialization that has the same API but offers a different scrolling user interface.
</p>
<p>
The logic of the Finder goes as follows: 
</p><ul>
<li>Panes are handled in an simple linked list, each having possibly one predecessor and one successor</li>
<li>The value from the #entity port of the pane containing the Finder, spawns the first pane.</li>
<li>Every time the #selection port of a pane is populated with a value, a new successor pane is created.</li>
<li>A transmission is created with the #selection of the previous pane as origin and the #entity port of the successor pane as destination.</li>
<li>Optionally, the user can specify further origin ports that should be taken into account.</li>
<li>This transmission sets the presentations that the user specifies.</li>
</ul>

<p>
Perhaps this sounds more complicated than it really is. Let's see an example and build a rudimentary file browser like the one on Mac. Such a browser displays for each directory a list of all the direct children, and selecting a directory spawns another pane to the right:
</p>
<figure><pre><code>browser := GLMFinder new.
browser title: 'Files'.
browser show: [ :a |
  a list 
	display: [ :directory | directory children ];
   format: #basename;
	when: [ :directory | directory exists ] ].</code></pre><figcaption></figcaption></figure>

<p>
In essence, the only thing we specify is what gets shown in each pane. We can open the browser on an input directory file reference:
</p>
<figure><pre><code>browser openOn: MooseModel root allModels first allModelNamespaces.</code></pre><figcaption></figcaption></figure>

<p>
<img src="figures/glamour-finder-example.png"/> 
</p>
<p>
The Pager can be specified in exactly the same way, only for a different browser instance:
</p>
<figure><pre><code>browser := GLMPager new.
browser title: 'Files'.
browser show: [ :a |
  a list 
	display: [ :directory | directory children ];
   format: #basename;
	when: [ :directory | directory exists ] ].</code></pre><figcaption></figcaption></figure>

<p>
<img src="figures/glamour-pager-example.png"/> 
</p>
<p>
Please note how the scrollbar of the Pager shows the amount of panes more explicitly.
</p>
<p class="todo">forwarding</p>

<h3 id="h3accumulator">Accumulator</h3>
<p>
Accumulator is an implicit type of browser whose only behavior is to accumulate panes.
</p>
<p>
Every time the #entity port of the parent pane is populated, the Accumulator searches through its panes to find one that corresponds the entity. If none is found, a new pane is created with the #entity populated. Just like in the case of the Finder, the user can specify the presentations that go in each pane.
</p>
<p>
The main use case behind this type of browser is an editor like the Eclipse main view. For this purpose, it is typically combined with a Tabulator (more details about browser composition can be seen in <a href=""></a>). The snippet below shows an example:
</p>
<figure><pre><code>| browser |
browser := GLMTabulator new.
browser column: #list; column: #details span: 2.
browser title: 'Class Viewer'.
browser transmit to: #list; andShow: [ :a | 
  a list 
    format: #name;
    title: 'Classes' ].
browser transmit to: #details; from: #list; andShowIfNone: [ :a |
  | accumulator |
  accumulator := GLMAccumulator new.
  accumulator show: [ :some | 
    some title: #name.
    some text 
      display: #formattedSourceText ].
  a custom: accumulator ].</code></pre><figcaption></figcaption></figure>

<p>
The overall browser is a Tabulator with two panes: one showing the list of all classes, and 
one showing the source code of each selected class in an Accumulator.
</p>
<p>
The <code>#selection</code> port of the left pane is linked with the <code>#entity</code> port of the right pane. Thus, every time we select a class from the list on the left, the Accumulator will spawn a new tab. A particularity of this example is the use of <code>andShowIfNone:</code> when specifying the transmission. Because the Accumulator is meant to accumulate, and not be replaced with every new transmission, we want the transmission to only install a new presentation when there is none in the target pane.
</p>
<p>
Running the browser on all classes from the ArgoUML model, spawns a window as shown below.
</p>
<p>
<img src="figures/accumulator.png"/>
</p>
<p>
The Accumulator also offers two more special ports: <code>#entityToSelect</code>, and <code>#activeEntity</code>.
</p>
<p>
The <code>#entityToSelect</code> port is meant to be used as an input port, and populating it with a value causes the renderer to try to select a tab that corresponds to the value. The behavior is similar to the one of <code>#entity</code>, the difference being that it will not create a new tab if the tab does not yet exist.
</p>
<p>
The <code>#activeEntity</code> port is a special one that is populated with the value behind the currently selected tab.
</p>
<p>
We can use these two ports can be used to completely simulate the Eclipse like behavior:
</p><ul>
<li>When we strong select (i.e., double click) the class from the left pane, we get a new tab. For this we connect the <code>#strongSelection</code> port the list pane with the <code>#entity</code> port from the details pane.</li>
<li>When we simply select the class from the left pane, we try to select the corresponding tab. To achieve this we connect the <code>#selection</code> port from the left pane with the <code>#entityToSelect</code> port from the details pane.</li>
<li>Finally, when we select a new tab, we select the corresponding element from the list. To this end, we connect the <code>#activeEntity</code> port from the right pane with the <code>#selection</code> port from the left pane.</li>
</ul>

<p>
The code below shows the complete script:
</p>
<figure><pre><code>| browser |
browser := GLMTabulator new.
browser column: #list; column: #details span: 2.
browser title: 'Class Viewer'.
browser transmit to: #list; andShow: [ :a | 
  a list 
    format: #name;
    title: 'Classes' ].
browser transmit to: #details; from: #list port: #strongSelection; andShowIfNone: [ :a |
  | accumulator |
  accumulator := GLMAccumulator new.
  accumulator show: [ :some | 
    some title: #name.
    some text 
      display: #formattedSourceText ].
  a custom: accumulator ].
browser transmit to: #details port: #entityToSelect; from: #list. 
browser transmit to: #list port: #selection; from: #details port: #activeEntity.</code></pre><figcaption></figcaption></figure>


<h3 id="h3composingbrowsers">Composing browsers</h3>
<p>
Browsers encapsulate a navigation flow, and in many cases we would like to reuse this flow in a larger context. This reuse is possible because browsers are presentations. Thus, they can be used within another browser by simply adding it as a presentation to a pane.
</p>
<p>
Suppose that we would want to build a browser that given a starting method would allow us to navigate the chain of all invoking methods (similar to the Senders browser in Pharo). Given that we deal with a deep tree, we might want to use a Finder to navigate this structure. As possible result can be seen below.
</p>
<p>
<img src="figures/glamour-classic-chaser.png"/>
</p>
<p>
In our example, we are actually dealing with two browsers:
</p><ol><li>an inner Finder that spawns the next pane with the invoking methods for each selected method, and</li>
<li>an overall Tabulator that shows the Finder on top, and the preview of the source code below.</li>
</ol>

<p>
Let's build the two step by step. First, we build the <code>innerBrowser</code>:
</p>
<figure><pre><code>innerBrowser := GLMFinder new.
innerBrowser show: [:a | 
  a list
    title: [:each | 'Methods invoking ', each name ];
    display: #invokingMethods ;
    format: #mooseName ].</code></pre><figcaption></figcaption></figure>

<p>
To see the source code for each method, we can now embed this browser in a Tabulator that previews the code for the currently selected method in a below pane. The embedding is achieved using <code>custom:</code>:
</p>
<figure><pre><code>browser := GLMTabulator new.
browser title: [:each | 'Classic chaser on ', each mooseName ].
browser row: #methods; row: #source.
browser transmit to: #methods; andShow: [ :a | 
  a custom: innerBrowser ].
browser transmit from: #methods; to: #source; andShow: [:a |
  a text display: #sourceText ].</code></pre><figcaption></figcaption></figure>

<p>
This works as follows. The inner Finder takes care of navigating through methods. Whenever a method is selected, it automatically sets the <code>#selection</code> port of the pane holding the Finder, and this in turn triggers the transmission from the overall Tabulator.
</p>
<p>
Executing the script on a Method entity reveals a browser like in the screenshot. For example, if you have an ArgoUML model loaded, you can execute it by:
</p>
<figure><pre><code>browser openOn: (
  MooseModel root allModels first allMethods 
    entityNamed: #'org::argouml::model::Facade.getName()')</code></pre><figcaption></figcaption></figure>

<p>
One drawback of this browser is that at any point we can see the source code of only one method. To make it more interesting, we could turn the browser around a bit, and embed the Tabulator inside the Finder. For each pane in the Finder we would display two panes: one showing the current list of invoking methods, and one showing the code preview of the selected method. When a method is selected, we want to see its invoking methods to the right in the Finder. See the below screenshot for more details.
</p>
<p>
<img src="figures/glamour-chaser.png"/>
</p>
<p>
In this example, we are dealing with the following browser:
</p><ol><li>an inner Tabulator that shows the invoking methods of a given method, and takes care of the source code preview of the selected method, and</li>
<li>an overall Finder browser that spawns the next pane for each selection.</li>
</ol>

<p>
As before, first we build the <code>innerBrowser</code>:
</p>
<figure><pre><code>innerBrowser := GLMTabulator new.
innerBrowser row: #methods; row: #source.
innerBrowser transmit to: #methods; andShow: [ :a | 
  a list
    title: [:each | 'Methods invoking ', each name ];
    display: #invokingMethods ;
    format: #mooseName ].
innerBrowser transmit from: #methods; to: #source; andShow: [:a |
  a text display: #sourceText ].</code></pre><figcaption></figcaption></figure>

<p>
No magic here, just a plain Tabulator. While this works just fine as standalone, because the Tabulator is an explicit browser, it does not automatically populate the <code>#selection</code> port like in the case of the Finder. Thus, when inside the Finder it we still need to inform the pane surrounding our browser that the <code>#selection</code> port has changed. To do this, we have to explicitly export the <code>#selection</code> port from the <code>#methods</code> pane to the <code>#selection</code> port of the <code>#outer</code> pane:
</p>
<figure><pre><code>innerBrowser transmit from: #methods; toOutsidePort: #selection.</code></pre><figcaption></figcaption></figure>

<p>
Once this accomplished, we can now embed it in a Finder using <code>custom:</code>:
</p>
<figure><pre><code>browser  := GLMFinder new.
browser title: [ :each | 'Reference browser on ', each mooseName ].
browser show: [ :a |
  a custom: innerBrowser ].</code></pre><figcaption></figcaption></figure>

<p>
The new browser can be opened using the same code as before:
</p>
<figure><pre><code>browser openOn: (
  MooseModel root allModels first allMethods 
    entityNamed: #'org::argouml::model::Facade.getName()')</code></pre><figcaption></figcaption></figure>

<p>
These examples show how we can compose browsers in different ways to obtain complex interactions. An important issue is to take care of what values go outside the browser. When embedding an implicit browser (e.g., Finder) we can directly rely on the <code>#selection</code> port of the outer pane. When embedding an explicit browser (e.g., Tabulator) we need to explicitly populate the outer ports.
</p>

<h2 id="h2handlingactions">Handling actions</h2>
<p>
Every Presentation can be configured to react to Actions. Actions represent commands that are to be triggered by the user. 
</p>
<p>
Actions are described by three parameters: <code>title</code>, <code>key</code>, and <code>icon</code>. An action with a title appears in the contextual menu of the presentation. If the action has an icon attached, it has the chance of appearing in the toolbar of a browser. An action with a key is mapped on a shortcut involving the platform modifier and the key (e.g., on Mac it is CMD+key). 
</p>
<p>
The protocol to create actions has several selectors to accommodate the possible combinations. The most basic ones are as follows:
</p><ul>
<li><code>act:entitled:</code> sets the title;</li>
<li><code>act:icon:entitled:</code> sets the icon and the title;</li>
<li><code>act:on:</code> sets the shortcut.</li>
</ul>

<p>
The <code>act:</code> expects a block with several optional parameters: the first parameter is given by the presentation object, and the rest are populated by the input entities.
</p>
<p>
By providing access to the presentation object, the Action also enable the population of the ports of the pane holding the presentation. 
</p>
<p>
For example, if we want to implement the Evaluator pane from the Moose Finder (see <a href=""></a>) we can write an action that takes the selected text, evaluates it and populates the <code>#selection</code> port with the result:
</p>
<figure><pre><code>finder show: [ :a |
  a text
    &quot;...&quot;
    act: [ :text :entity | 
      text selection:
        (Compiler evaluate: text selectedText for: entity logged: false)  ]
      on: $o 
      entitled: 'Open script (o)' ].</code></pre><figcaption></figcaption></figure>

<p>
The same action can also be written more succinctly:
</p>
<figure><pre><code>finder show: [ :a |
  a text
    &quot;...&quot;
    populate: #selection 
      on: $o 
      entitled: 'Open script (o)' 
      with: [ :text :entity | 
        Compiler evaluate: text selectedText for: entity logged: false  ] ].</code></pre><figcaption></figcaption></figure>

<p class="note">Given the access to the presentation object we have access to the entire browser, and thus we can also directly modify it. However, affecting directly the overall browser bypasses the mechanism of Glamour, breaks encapsulation and it makes the understanding and maintenance more difficult. Instead, it is preferred that each presentation affects only its own pane and let the propagation happen through explicit transmissions.</p>
<p>
There are several kinds of actions supported by Glamour. First, there are actions that are supposed to work for the entire presentation, and actions that are meant to work only contextually when there is a selection. These are specified using the following messages:
</p><ul>
<li>the <code>act:</code> messages define actions for the entire presentation. These actions are typically rendered in the toolbar from the top-right of the presentation.</li>
<li>the <code>selectionAct:</code> messages define actions that should be active only when there is a selection. These actions are typically mapped on the contextual menu.</li>
</ul>

<p>
The above messages define static actions. That means that regardless of what the values of the ports are, these actions will always be available. However, at times, we can also decide to provide actions dynamically depending on the port values. This can be achieved through <code>dynamicActions:</code> and <code>dynamicActionsOnSelection:</code> messages. These messages receive a block that will be evaluated on the presentation and should return a list of GLMAction objects.
</p>
<p class="note">These messages are meant to be used as a last resort because they work with the internals of Glamour.</p>

<h2 id="h2updatingbrowsers">Updating browsers</h2>
<p>
When the objects browsed get changed, we need the browser to update and reflect the new state.
</p>
<p>
In Glamour, there are two ways in which this is accomplished: 
</p><ol><li>explicitly, by sending #update to a presentation, or </li>
<li>implicitly, by making a presentation listen to Announcements thrown by the objects.</li>
</ol>

<p>
The explicit mechanism is simple and is typically accessible by means of actions. For example, to see the list of all models registered in the root model we could use a browser as shown below.
</p>
<figure><pre><code>| browser |
browser := GLMTabulator new.
browser title: 'Model list with manual update'.
browser column: #list.
browser transmit to: #list; andShow: [:a | 
  a list 
    act: [:list | list update] 
      icon: GLMUIThemeExtraIcons glamorousRefresh
      entitled: 'Update';
    format: #name ].
browser openOn: MooseModel root.</code></pre><figcaption></figcaption></figure>

<p>
You can affect the root model by simply adding a new model:
</p>
<figure><pre><code>MooseModel root add: MooseModel new.</code></pre><figcaption></figcaption></figure>

<p>
The list does not show the new model. We can update the list by pressing the update icon.
</p>
<p>
For the Announcement-based mechanism to work, you need an object that does raise Announcements. Once you have such an object, you can use <code>GLMPresentation&gt;&gt;#updateOn: anAnnouncement from: anAnnouncer</code> to control what announcements should trigger the update of the presentation.
</p>
<p>
Let us take an example. A MooseEntity sends several announcements when its inner structure changes. One of these Announcements is <code>MooseEntityAdded</code>. However, because the MooseEntity is not an Announcer, it uses an announcer object to send the announcements. If you want to have a list of models from the root model updated every time a new model is added, you can register to the <code>MooseEntityAdded</code> announcement sent by the <code>model announcer</code>:
</p>
<figure><pre><code>| browser |
browser := GLMTabulator new.
browser title: 'Model list with implicit update'.
browser column: #list.
browser transmit to: #list; andShow: [:a | 
  a list 
    format: #name;
    updateOn: MooseEntityAdded from: [:model | model announcer ] ].</code></pre><figcaption></figcaption></figure>

<p>
To watch the effect of an announcement, you can test it with:
</p>
<figure><pre><code>MooseModel root add: MooseModel new.</code></pre><figcaption></figcaption></figure>

<p class="todo">validation</p>

<h2 id="h2rendering">Rendering</h2>
<p>
The Glamour model is formed by entities such as Browser, Pane, Presentation and Transmission (see <a href=""></a>), and its main goal is to handle the abstract logic of the browser. Even if the main goal of Glamour is to produce actual browsers, this model is independent of the rendering technology.
</p>
<p>
This decoupling is realized through a Visitor pattern. Every Pane and Presentations classes  understand <code>renderGlamorouslyOn:</code>, and as an implementation, they delegate to a Renderer. It is then the job of the renderer to actually produce the actual widget that will appear on the screen and link it with the model of Glamour. The basic structure can be seen in the below class diagram.
</p>
<p>
<img src="figures/glamour-rendering.png"/>
</p>
<p>
The Renderer class provides the abstract class that is meant to be subclassed by each new rendering platform. The default implementation uses Morphic, the default Pharo user interface framework, and it can be found in the GLMMorphicRenderer class.
</p>
<p>
To better understand how the mechanism works, let us take a closer look at the code related to rendering a text presentation:
</p>
<figure><pre><code>GLMTextPresentation&gt;&gt;renderGlamorouslyOn: aRenderer 
  self registerAnnouncements.
  ^ aRenderer renderTextPresentation: self</code></pre><figcaption></figcaption></figure>

<p>
The corresponding code in the MorphicRenderer uses a helper class:
</p>
<figure><pre><code>renderTextPresentation: aTextPresentation 
  ^ GLMMorphicTextRenderer render: aTextPresentation from: self</code></pre><figcaption></figcaption></figure>

<p>
Finally, the GLMMorphicTextRenderer provides the actual code:
</p>
<figure><pre><code>GLMMorphicTextRenderer&gt;&gt;render: aPresentation
  textModel := GLMTextModel new glamourPresentation: aPresentation &quot;...&quot;.
  textMorph := aPresentation highlightSmalltalk 
        ifTrue: [self smalltalkTextMorphForModel: textModel]
        ifFalse: [self textMorphForModel: textModel].
  &quot;... more code that sets 
       the state of the presentation based on the morph events,
       and the state of the morphs based on the internal Glamour announcements&quot;
  ^ textMorph</code></pre><figcaption></figcaption></figure>

<p>
The implication of this design is twofold. First, if you want to support a new platform, you have to create a new subclass of Renderer. Second, if you create a new presentation or browser, you have to also provide the rendering code in all Renderers.
</p>

<h2 id="h2examples">Examples</h2>
<p>
Glamour offers a self documenting browser with a set of examples covering the various features.
You can get to this browser by executing:
</p>
<figure><pre><code>GLMBasicExamples open</code></pre><figcaption></figcaption></figure>

<p>
The browser offers several examples to the left. When selecting an example, it displays an instance of a browser and the source code for the browser.
</p>
<p>
<img src="figures/basic-examples-browser.png"/>
</p>
<h1 id="h1theglamoroustoolkit">The Glamorous Toolkit</h1>

<p class="todo">TODO</p>
<h1 id="h1checkingandreportingwitharki">Checking and reporting with Arki</h1>
<p>
While a large part of Moose is focused on providing interactive capabilities to build and perform analysis, it is often desirable to carve in stone a set of concerns that we want to watch for, and then have a tool check them and produce a report.
</p>
<p>
Such a report is useful when it addresses needs of the development team. Some concerns are trivial, some are complex. Some are generic, some are very specific. Regardless of their nature, if they are of concern to the team, they have a place in the report. Similarly, it does not matter how smart a rule is, it is of no use if there is no stakeholder.
</p>
<p>
Thus, it is of little use to provide an almighty report: on the one hand it will include many things that are not of direct interest, on the other hand it will not address concerns that are specific to the project.
</p>
<p>
Instead, Moose provides Arki, a reporting infrastructure, that allows the analyst to build a reporting tool in an iterative way. Arki provides an interface through which an index of multiple concerns can be defined. A concern can be a strict rule (e.g., the database should not be called from the user interface layer), or it can be an issue that we want to watch for (e.g., which classes call the database).
</p>
<p>
Besides the content, a crucial element in a report is also the way the content is presented. Thus, Arki makes use of all the presentation capabilities of Moose to allow the analyst to build dedicated presentations.
</p>
<p>
All in all, Arki makes custom reporting practical.
</p>

<h2 id="h2creatingadedicatedreportfromscratch">Creating a dedicated report from scratch</h2>
<p>
For the purpose of this exercise, let's start a report dedicated to ArgoUML. To identify relevant concerns, I browsed the documentation present on the ArgoUML site. More specifically, the development guidelines. Here are some excerpts:
</p><ul>
<li><em>``All instance variables are private.</em>''</li>
<li><em>``Don't use deprecated methods or classes.</em>''</li>
<li><em>``Don't use very long package and class names...  keep class names shorter than 25 chars</em>''</li>
</ul>

<p>
Let's start with the first issue: ``all instance variables are private''. To check this, we create a query that retrieves all attributes that are not static, that are not stub and that are not private:
</p>
<figure><pre><code>spec := REPConcernSpecification on: MooseModel root allModels first.
spec 
  query: 'Non-private attributes' 
  meaning: 'The ArgoUML guidelines say that all attributes must be private'
  as: [:model | model allAttributes select: [ :each | 
      each parentType isStub not and: [ each isPrivate not and: [
        each hasClassScope not ]]]].
spec open</code></pre><figcaption></figcaption></figure>

<p>
Executing this script results in a browser as below. To the left we have the index with our item in red. It is red, because indeed the ArgoUML violates this concern. Selecting the concern reveals the list of offending attributes to the right. In fact, list to the right is 
a complete instance of a MooseFinder that offers us various possibilities for navigation and enquiry.
</p>
<p>

<figure>
	<img src="figures/arki-argo-non-private-attributes.png"/>
	<figcaption>Argo non private attributes</figcaption>
</figure>
</p>
<p>
In the same way we can define the rest of the concerns. For convenience, we can also group concerns into composites:
</p>
<figure><pre><code>spec := REPConcernSpecification on: MooseModel root allModels first.
spec label: 'ArgoUML Report'.
spec composite: 'ArgoUML design problems' meaning: '' with: [
  spec 
    query: 'Non-private attributes' 
    meaning: 'The ArgoUML guidelines say that all attributes must be private'
    as: [:model | model allAttributes select: [ :each | 
        each parentType isStub not and: [ 
          each isPrivate not and: [ each hasClassScope not ]]]].
  spec
    query: 'Deprecated classes still in use'
    meaning: 'Deprecated classes should not be used anymore'
    as: [:model | model allModelClasses select: [ :each | 
        (each isAnnotatedWith: 'Deprecated') and: [ 
          (each clientClasses reject: [:e | e = each]) notEmpty ]]].
  spec
    query: 'Deprecated methods still in use'
    meaning: 'Deprecated methods should not be used anymore'
    as: [:model | model allMethods select: [ :each | 
        (each isAnnotatedWith: 'Deprecated') and: [ 
          (each invokingClasses reject: [:e | e = each parentType ]) notEmpty ]]]
	].
spec composite: 'ArgoUML naming problems' meaning: '' with: [
  spec 
    query: 'Classes with too long name' 
    meaning: 'A class should not have a name with more than 25 characters'
    as: [:model | model allModelClasses select: [ :each | 
        each nameLength &gt; 25 ] ].
	].
spec open</code></pre><figcaption></figcaption></figure>

<p>

<figure>
	<img src="figures/arki-argo-multiple.png"/>
	<figcaption>Multiple rules in Arki</figcaption>
</figure>
</p>
<p>
Up to now we only defined concerns that are expressed with a query and that spawn a group of items as a result. If the group is not empty, the concern is considered to be violated and it turns red. If the group is empty, it appears green.
</p>
<p>
There are cases in which an issue is better represented with a presentation different from a list. Also, a concern is not necessarily black or white, but it can simply be something we might want to watch for.
</p>
<p>
Reading further ArgoUML documentation, we get to a section dealing with the use of Facades in ArgoUML. Here are some relevant excerpts:
</p><ul>
<li><em>``A Facade class provides the most common functions</em>''</li>
<li><em>``For each subsystem X in ArgoUML that uses the subsystem Y, the designer of the subsystem X must decide if he wants to use the API of Y when using the subsystem Y ... or use the Facade class of subsystem Y</em>''</li>
</ul>

<p>
Given that the use of Facades is important in ArgoUML, a concern can be to make them more visible so that people are aware of their existence. Furthermore, because ArgoUML offers one Facade per module, it would be interesting to offer an overview of the modules that contain such a Facade.
</p>
<p>
Thus, we would like to create a small visualization to highlight the places that contain Facades. Given that this task presupposes more code, it requires the creation of a class:
</p>
<figure><pre><code>REPComputedConcern subclass: #TMBArgoUMLFacadeMap
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'TheMooseBook-Examples'</code></pre><figcaption></figcaption></figure>

<p>
In this class we define the following methods:
</p>
<figure><pre><code>label 
  ^ 'Facade watcher'</code></pre><figcaption></figcaption></figure>

<figure><pre><code>explanation 
  ^ 'Map of packages containing Facade classes'</code></pre><figcaption></figcaption></figure>

<figure><pre><code>computeResult
  ^ self model allModelNamespaces select: [ :each | 
    each classes anySatisfy: [:class | '*Facade*' match: class name] ]</code></pre><figcaption></figcaption></figure>

<figure><pre><code>browser
  | browser |
  browser := GLMTabulator new.
  browser column: #map; column: #code.
  browser transmit to: #map; andShow: [:a | 
    a mondrian
      title: 'Package map';
      painting: [:view :facadeNamespaces | 
        self viewFacadeNamespaces: facadeNamespaces on: view ]].
  browser transmit to: #code; from: #map; andShow: [:a | 
    a text 
      title: 'Facade class';
      display: [ :namespace | 
        (namespace classes detect: [:each | 
          '*Facade*' match: each name ]) sourceText ];
      when: [:namespace | self result includes: namespace ]].
  ^ browser startOn: self result</code></pre><figcaption></figcaption></figure>

<figure><pre><code>viewFacadeNamespaces: facadeNamespaces on: view
  view shape label 
    text: #name; 
    fontColor: [:each |
      (facadeNamespaces includes: each)
        ifTrue: [Color blue] 
        ifFalse: [Color gray]].
  view nodes: (self model allNamespaces select: [:each | 
    'org::argouml*' match: each mooseName ]).
  view shape horizontalOrthogonalLine.
  view edgesFrom: #parentScope.
  view horizontalTreeLayout</code></pre><figcaption></figcaption></figure>

<p>
The first two methods provide the proper label and explanation text. The third method takes care of computing the result of the query. The last two are more interesting as they define a browser to present the information. These two methods make use of Glamour and Roassal.
</p>
<p>
Once we have the class, we simply add it to the overall report by inserting:
</p>
<figure><pre><code>spec composite: 'To watch for' with: [
  spec concern: TMBArgoUMLFacadeMap new ].</code></pre><figcaption></figcaption></figure>

<p>
Spawning the complete report results in a browser like shown below. First, the &quot;Facade watcher&quot; concern is black denoting that we do not expect a certain answer. Second, the presentation is offered in the form of the browser defined above: the visualization to the left shows in blue the packages that contain a Facade, and selecting one shows the source code to the right.
</p>
<p>

<figure>
	<img src="figures/arki-argo-complete.png"/>
	<figcaption>Arki including an embedded visual browser</figcaption>
</figure>
</p>
<p>
That is it. We have just built a dedicated report that can act both as a checker of hard rules, and as a documentation with complex presentations.
</p>

</p>  				</div> 			</div>		</div>	</body></html>